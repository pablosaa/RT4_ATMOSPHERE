! *****************************************************************************************
! Set of subroutines to manage netCDF input/output files.
! -----------------------------------------------------------------------------------------
! * read_wyosonde: read netCDF files from radiosondes with homoginized layers,
! * createncdf   : create and setup variables and dimensions for RT output files,
! * storencdf    : save the TB variables into the previous created netCDF file,
! * MP_storencdf : save the microphysics variables into the created netCDF file.
!
! (c) 2018 Pablo Saavedra G. (pablo.saa@uib.no)
! Geophysical Institute, University of Bergen
! SEE LICENSE.TXT
! --------------------------------------------------------------------------------------


! ______________________________________________________________________________________
! --------------------------------------------------------------------------------------
! Subroutine to read Wyoming Radiosonde database from the NetCDF-file generated by the
! code in repository github.com/pablosaa/WyoSondes
!
! The loaded variables are introduced to the RT3/RT4 radiative transfer code for
! calculation of Brightness Temperature Fields.
! -------------------------------------------------------------------------------------
subroutine read_wyosonde(ncflen,ncfile,mxgridx,mxgridy,mxlyr,mxtime,hgt_lev,&
     &press_lev,temp_lev,relhum_lev,cloud_water_lev,&
     &rain_water_lev,cloud_ice_lev,snow_lev,graupel_lev, qidx,&
     &ngridx,ngridy,del_xy,nlyr,ntime,lat,lon,year,month,day,hour,&
     &origin_str)
  use netcdf
  implicit none

  integer, intent(in) :: ncflen
  character(len=ncflen), intent(in) :: ncfile

  ! -- Here come variables declaration alike the onses used by RT3

  integer, intent(in) ::   mxgridx, mxgridy, mxlyr, mxtime
  real(kind=8), intent(inout), dimension(mxgridx,mxgridy,0:mxlyr,mxtime) :: hgt_lev,temp_lev,press_lev,relhum_lev
  real(kind=8), intent(inout), dimension(mxgridx,mxgridy,mxlyr,mxtime) :: cloud_water_lev,rain_water_lev,cloud_ice_lev
  real(kind=8), intent(inout), dimension(mxgridx,mxgridy,mxlyr,mxtime) :: snow_lev,graupel_lev
  integer(kind=4), intent(inout), dimension(mxgridx,mxgridy,mxtime) :: qidx
  integer, intent(out) :: ngridx, ngridy, nlyr, ntime
  real(kind=4), intent(out), dimension(mxgridx, mxgridy) :: lat, lon
  real(kind=4), intent(out), dimension(mxgridx, mxgridy, mxtime) :: year,month,day,hour
  real(kind=4), intent(out) :: del_xy(2)
  character(len=*), intent(out) :: origin_str
  ! -- end of variable declaration

  integer :: status
  integer :: ncid, ndims_in, nvars_in, ngatts_in, unlimdimid_in
  integer :: VarId
  character(len=10) :: dim_name(4)
  character(len=10) :: varname
  integer :: i, NN, dim_len(4)
  integer, allocatable, dimension(:) :: myVarIDs
  real, allocatable, dimension(:,:,:,:) :: Var4D
  real, allocatable, dimension(:,:,:) :: Var3D
  real, allocatable, dimension(:,:) :: Var2D
  real, allocatable, dimension(:) :: Var1D

  ! Initialazing the variables to a fixed value
  hgt_lev = 0.
  temp_lev =0.
  press_lev = 0.
  relhum_lev = 0.
  cloud_water_lev = 0.
  rain_water_lev = 0.
  cloud_ice_lev = 0.
  snow_lev = 0.
  graupel_lev = 0.
  lat = 0.
  lon = 0.
  year = 0.
  month = 0.
  day = 0.
  hour = 0.

  ! -----------------------------------------------------------------------------
  ! Open file and read directory
  print*,'netCDF input files is', ncflen, ' : ', ncfile
  
  status = nf90_open(ncfile,NF90_NOWRITE,ncid)
  if(status.ne.0) then
     print*, 'Cannot open netCDF-file: '//trim(ncfile)
     stop
  end if
  status = nf90_inquire(ncid,ndims_in,nvars_in,ngatts_in,unlimdimid_in)
  ! Get ID of unlimited dimension

  !! print*,ndims_in, nvars_in, ngatts_in, unlimdimid_in
  do i=1,ndims_in
     ! assigning dimension name and length:
     status = nf90_inquire_dimension(ncid,i,dim_name(i), dim_len(i))
     select case(trim(dim_name(i)))
     case('xn')
        ngridx = dim_len(i)
     case('yn')
        ngridy = dim_len(i)
     case('lev')
        nlyr = dim_len(i)
     case('time')
        ntime = dim_len(i)
     case default
        print*, 'netCDF file dimension '//trim(dim_name(i))//' unknown!'
        stop
     end select
  end do
  allocate(myVarIDs(nvars_in))
  status = nf90_inq_varids(ncid,nvars=NN,varids=myVarIDs)

  ! Reading variables:
  allocate(Var4D(dim_len(1),dim_len(2),dim_len(3),dim_len(4)))
  allocate(Var3D(dim_len(1),dim_len(2),dim_len(4)))
  allocate(Var2D(dim_len(1),dim_len(2)))
  allocate(Var1D(dim_len(4)))
  Var4D = -99
  Var3D = -99
  Var2D = -99
  Var1D = -99
  do i=1,nvars_in
     status = nf90_inquire_variable(ncid, myVarIDs(i), varname, ndims = NN)
     if(status /= nf90_NoErr) print*, 'ERROR: NetCDF variable name cannot be assigned'
     status = nf90_inq_varid(ncid, varname, VarId)

     if(status /= nf90_NoErr) print*, 'ERROR: NetCDF variable ID for ',varname,' cannot be retrieved'
     ! Loading the variables from NetCDF
     select case(NN)
     case(1)
        status = nf90_get_var(ncid, VarId, Var1D)
     case(2)
        status = nf90_get_var(ncid, VarId, Var2D)
     case(3)
        status = nf90_get_var(ncid, VarId, Var3D)
     case(4)
        status = nf90_get_var(ncid, VarId, Var4D)
     case default
        print*,trim(varname),'WARNING: neither 4D nor 3D nor 2D variable!!'
        continue
     end select
     if(status /= nf90_NoErr) print*, 'error getting variable ', trim(varname)

     ! Assigning the data to RT3/4 variable names
     select case(trim(varname))
     case('HGT')
        hgt_lev(:dim_len(1),:dim_len(2),0,:) = spread(Var2D,dim=3,ncopies=ntime)
        ! for 2D variables:
     case('T2')
        temp_lev(:dim_len(1),:dim_len(2),0,:) = Var3D
     case('PSFC')
        press_lev(:dim_len(1),:dim_len(2),0,:) = Var3D
     case('Q2')
        relhum_lev(:dim_len(1),:dim_len(2),0,:) = Var3D
        ! for 3D variables:
     case('PHB')
        hgt_lev = 0
        ! Passing values to RT3 variables:
        hgt_lev(:dim_len(1),:dim_len(2),1:dim_len(3),:dim_len(4)) = Var4D
     case('P')
        press_lev = 0
        ! Passing values to RT3 variables:
        press_lev(:dim_len(1),:dim_len(2),1:dim_len(3),:dim_len(4)) = Var4D
     case('T')
        temp_lev = 0
        ! Passing values to RT3 variables:
        temp_lev(:dim_len(1),:dim_len(2),1:dim_len(3),:dim_len(4)) = Var4D
     case('QVAPOR')
        relhum_lev = 0
        ! Passing values to RT3 variables:
        relhum_lev(:dim_len(1),:dim_len(2),1:dim_len(3),:dim_len(4)) = Var4D
     case('QCLOUD')
        cloud_water_lev = 0
        ! Passing values to RT3 variables:
        cloud_water_lev(:dim_len(1),:dim_len(2),1:dim_len(3),:dim_len(4)) = Var4D
     case('QRAIN')
        rain_water_lev = 0
        ! Passing values to RT3 variables:
        rain_water_lev(:dim_len(1),:dim_len(2),1:dim_len(3),:dim_len(4)) = Var4D
     case('QICE')
        cloud_ice_lev = 0
        ! Passing values to RT3 variables:
        cloud_ice_lev(:dim_len(1),:dim_len(2),1:dim_len(3),:dim_len(4)) = Var4D
     case('QSNOW')
        snow_lev = 0
        ! Passing values to RT3 variables:
        snow_lev(:dim_len(1),:dim_len(2),1:dim_len(3),:dim_len(4)) = Var4D
     case('QGRAUP')
        graupel_lev = 0
        ! Passing values to RT3 variables:
        graupel_lev(:dim_len(1),:dim_len(2),1:dim_len(3),:dim_len(4)) = Var4D
     case('QIDX')
        ! Passing values to quality index:
        qidx(:dim_len(1),:dim_len(2),:dim_len(4)) = Var3D
     case('LAT')
        lat(:dim_len(1),:dim_len(2)) = Var2D
     case('LON')
        lon(:dim_len(1),:dim_len(2)) = Var2D
     case('year')
        year(:dim_len(1),:dim_len(2),:dim_len(4)) = Var3D
     case('month')
        month(:dim_len(1),:dim_len(2),:dim_len(4)) = Var3D
     case('day')
        day(:dim_len(1),:dim_len(2),:dim_len(4)) = Var3D
     case('hour')
        hour(:dim_len(1),:dim_len(2),:dim_len(4)) = Var3D
     case default
        print*, 'variable ',varname,' not assigned yet'
     end select
  end do

  ! ****************************
  ! Retrieving Global Attribute:
  status = nf90_get_att(ncid,NF90_GLOBAL,'grid_x',del_xy(1))
  status = nf90_get_att(ncid,NF90_GLOBAL,'grid_y',del_xy(2))
  status = nf90_get_att(ncid,NF90_GLOBAL,'origin',origin_str)
  
  ! ****************************
  ! Closing the NetCDF file
  status = nf90_close(ncid)
  
  deallocate(myVarIDs, Var4D, Var3D, Var2D, Var1D)

  return
end subroutine read_wyosonde
! ____________________________________________________________________________


! ============================================================================
! ----------------------------------------------------------------------------
! SUBROUTINE to create the RT3/4 output as NetCDF files 
!
! This subroutine only creates the NetCDF file with its corresponding
! variable names, dimentision and attributes.
! When the main code needs to write data, then the subroutine named
! 'storencdf' needs to be called in order to pass the FORTRAN variables
! to their corresponding NetCDF variables.
!
! ----------------------------------------------------------------------------
subroutine createncdf(ncflen, ncfile,NUMMU,NFREQ,NSTOKES,NLYR,XN,YN,&
     &LAYERS,freq_str,input_file,micro_phys,SELV,SLAT,SLON,origin_str)
  use netcdf
  implicit none

  integer, intent(in) :: ncflen
  character(len=ncflen), intent(in) :: ncfile
  character(len=*) input_file, micro_phys
  integer, intent(in) :: NUMMU, NFREQ,NSTOKES,NLYR, XN, YN
  real(kind=8), intent(in) :: freq_str(NFREQ), LAYERS(NLYR)
  real(kind=4), intent(in) :: SELV(XN,YN), SLAT(XN,YN), SLON(XN,YN)
  character(len=*), intent(in) :: origin_str
  
  ! internal variables
  integer :: I, status, ncid
  integer :: nDims, mu_id, stok_id, freq_id, lyr_id, time_id, xn_id, yn_id
  integer :: var_mu_id, var_stok_id, var_freq_id, var_lyr_id, var_time_id, var_elvid, var_latid, var_lonid
  integer :: var_xid, var_yid, var_tbup1_id, var_tbdn1_id, var_tbup0_id, var_tbdn0_id
  integer :: var_te2_id, var_rh2_id, var_pr2_id
  integer :: var_te_id, var_pr_id, var_rh_id
  integer :: var_qv_id, var_qc_id, var_qr_id, var_qs_id, var_qg_id, var_qi_id
  integer :: var_kextqc_id, var_kextqr_id, var_kextqs_id
  integer :: var_kextqg_id, var_kextqi_id, var_kextatm_id, var_kexttot_id
  integer :: var_salbtot_id, var_backsct_id, var_gcoeff_id
  integer, dimension(NSTOKES) :: stokes_var
  !real(kind=4), dimension(NTIME) :: TIMELINE
  integer :: nelv, NANGLES
  real(kind=8), dimension(10) :: elevations
  namelist/mwrobsang/nelv,elevations

  ! reading auxiliary input file with extra elevation angles
  OPEN(UNIT=100, FILE='mwrobsang',STATUS='old',IOSTAT=status)
  if(status.eq.0) then
     READ(UNIT=100,nml=mwrobsang)
     close(UNIT=100)
  else
     nelv = 0
     elevations = 0
  end if
  NANGLES = NUMMU + nelv
  
  status = nf90_create(trim(ncfile),NF90_CLOBBER,ncid)
  if(status /= nf90_NOERR) stop 'Output NetCDF was not possible to create'
  ! Defining dimensions
  status = nf90_def_dim(ncid, "theta_z", NANGLES, mu_id) ! NUMMU
  status = nf90_def_dim(ncid, "freq", NFREQ, freq_id)
  status = nf90_def_dim(ncid, "stokes", NSTOKES, stok_id)
  status = nf90_def_dim(ncid, "layer", NLYR, lyr_id)
  status = nf90_def_dim(ncid, "time", NF90_UNLIMITED, time_id)
  status = nf90_def_dim(ncid, "xn", XN , xn_id)
  status = nf90_def_dim(ncid, "yn", YN , yn_id)

  ! Define of variables
  status = nf90_def_var(ncid, "theta_z", NF90_REAL4, (/ mu_id /), var_mu_id)
  status = nf90_def_var(ncid, "freq", NF90_REAL4, (/ freq_id /), var_freq_id)
  status = nf90_def_var(ncid, "stokes", NF90_INT, (/ stok_id /), var_stok_id)
  status = nf90_def_var(ncid, "layer", NF90_REAl4, (/lyr_id/), var_lyr_id)
  status = nf90_def_var(ncid, "time", NF90_REAL, (/ time_id /), var_time_id)
  status = nf90_def_var(ncid, "TB_UP_TOA", NF90_REAL4, (/ mu_id, freq_id, stok_id, xn_id, yn_id, time_id /), var_tbup1_id)
  status = nf90_def_var(ncid, "TB_UP_GRD", NF90_REAL4, (/ mu_id, freq_id, stok_id, xn_id, yn_id, time_id /), var_tbup0_id)
  status = nf90_def_var(ncid, "TB_DN_GRD", NF90_REAL4, (/ mu_id, freq_id, stok_id, xn_id, yn_id, time_id /), var_tbdn0_id)
  status = nf90_def_var(ncid, "TB_DN_TOA", NF90_REAL4, (/ mu_id, freq_id, stok_id, xn_id, yn_id, time_id /), var_tbdn1_id)

  !
  ! Define atmospheric state variables
  ! 1. Station level variables 
  status = nf90_def_var(ncid, "T2m", NF90_REAL4, (/xn_id, yn_id, time_id/), var_te2_id)
  status = nf90_def_var(ncid, "RH2m", NF90_REAL4, (/xn_id, yn_id, time_id/), var_rh2_id)
  status = nf90_def_var(ncid, "P2m", NF90_REAL4, (/xn_id, yn_id, time_id/), var_pr2_id)

  ! 2. Atmospheric Profile variables 
  status = nf90_def_var(ncid, "temp", NF90_REAL4, (/xn_id, yn_id, lyr_id, time_id/), var_te_id)
  status = nf90_def_var(ncid, "press", NF90_REAL4, (/xn_id, yn_id, lyr_id, time_id/), var_pr_id)
  status = nf90_def_var(ncid, "rh", NF90_REAL4, (/xn_id, yn_id, lyr_id, time_id/), var_rh_id)
  status = nf90_def_var(ncid, "qv", NF90_REAL4, (/xn_id, yn_id, lyr_id, time_id/), var_qv_id)
  status = nf90_def_var(ncid, "qc", NF90_REAL4, (/xn_id, yn_id, lyr_id, time_id/), var_qc_id)
  status = nf90_def_var(ncid, "qr", NF90_REAL4, (/xn_id, yn_id, lyr_id, time_id/), var_qr_id)
  status = nf90_def_var(ncid, "qs", NF90_REAL4, (/xn_id, yn_id, lyr_id, time_id/), var_qs_id)
  status = nf90_def_var(ncid, "qg", NF90_REAL4, (/xn_id, yn_id, lyr_id, time_id/), var_qg_id)
  status = nf90_def_var(ncid, "qi", NF90_REAL4, (/xn_id, yn_id, lyr_id, time_id/), var_qi_id)
  ! Definition of Micro-physics frequency dependent variables (Profiles)
  status = nf90_def_var(ncid, "kext_tot", NF90_REAL4, (/xn_id, yn_id, lyr_id, freq_id, time_id/), var_kexttot_id)
  status = nf90_def_var(ncid, "kext_atm", NF90_REAL4, (/xn_id, yn_id, lyr_id, freq_id, time_id/), var_kextatm_id)
  status = nf90_def_var(ncid, "kext_qc", NF90_REAL4, (/xn_id, yn_id, lyr_id, freq_id, time_id/), var_kextqc_id)
  status = nf90_def_var(ncid, "kext_qr", NF90_REAL4, (/xn_id, yn_id, lyr_id, freq_id, time_id/), var_kextqr_id)
  status = nf90_def_var(ncid, "kext_qs", NF90_REAL4, (/xn_id, yn_id, lyr_id, freq_id, time_id/), var_kextqs_id)
  status = nf90_def_var(ncid, "kext_qg", NF90_REAL4, (/xn_id, yn_id, lyr_id, freq_id, time_id/), var_kextqg_id)
  status = nf90_def_var(ncid, "kext_qi", NF90_REAL4, (/xn_id, yn_id, lyr_id, freq_id, time_id/), var_kextqi_id)
  status = nf90_def_var(ncid, "alb_tot", NF90_REAL4, (/xn_id, yn_id, lyr_id, freq_id, time_id/), var_salbtot_id)
  status = nf90_def_var(ncid, "back_scatt", NF90_REAL4, (/xn_id, yn_id, lyr_id, freq_id, time_id/), var_backsct_id)
  status = nf90_def_var(ncid, "g_coeff", NF90_REAL4, (/xn_id, yn_id, lyr_id, freq_id, time_id/), var_gcoeff_id)
 
  ! grid-based variables
  status = nf90_def_var(ncid, "xn", NF90_INT, (/ time_id /), var_xid)
  status = nf90_def_var(ncid, "yn", NF90_INT, (/ time_id /), var_yid)

  status = nf90_def_var(ncid, "elevation", NF90_REAL4, (/xn_id, yn_id/), var_elvid)
  status = nf90_def_var(ncid, "latitude", NF90_REAL4, (/xn_id, yn_id/), var_latid)
  status = nf90_def_var(ncid, "longitude", NF90_REAL4, (/xn_id, yn_id/), var_lonid)

  ! Adding Attributes
  status = nf90_put_att(ncid,var_mu_id,"short_name","theta_z")
  status = nf90_put_att(ncid,var_mu_id,"long_name","Zenithal angle")
  status = nf90_put_att(ncid,var_mu_id,"units","degree")
  status = nf90_put_att(ncid,var_mu_id,"N_obs_angles",nelv)
  status = nf90_put_att(ncid,var_mu_id,"Obs_angles_degree",elevations(:nelv))
  status = nf90_put_att(ncid,var_mu_id,"N_sim_angles",NUMMU)

  status = nf90_put_att(ncid,var_stok_id,"short_name","stk")
  status = nf90_put_att(ncid,var_stok_id,"long_name","Stokes_vector")
  status = nf90_put_att(ncid,var_stok_id,"units","1")

  status = nf90_put_att(ncid,var_lyr_id,"short_name","layer")
  status = nf90_put_att(ncid,var_lyr_id,"long_name","profile layer height")
  status = nf90_put_att(ncid,var_lyr_id,"units","km")
  status = nf90_put_att(ncid,var_lyr_id,"_FillValue", -999.9)

  status = nf90_put_att(ncid,var_freq_id,"short_name","freq")
  status = nf90_put_att(ncid,var_freq_id,"long_name","Radiometric frequency")
  status = nf90_put_att(ncid,var_freq_id,"units","GHz")

  status = nf90_put_att(ncid,var_time_id,"short_name","time")
  status = nf90_put_att(ncid,var_time_id,"long_name","days since 1970.1.1 00:00:00")
  status = nf90_put_att(ncid,var_time_id,"units","day")
  status = nf90_put_att(ncid,var_time_id,"_FillValue", -999.9)

  status = nf90_put_att(ncid,var_tbup1_id,"short_name","TB_UP_TOA")
  status = nf90_put_att(ncid,var_tbup1_id,"long_name","TOA Brightness Temperature (Upwelling)")
  status = nf90_put_att(ncid,var_tbup1_id,"units","K")
  status = nf90_put_att(ncid,var_tbup1_id,"_FillValue", -999.9)

  status = nf90_put_att(ncid,var_tbdn1_id,"short_name","TB_DN_TOA")
  status = nf90_put_att(ncid,var_tbdn1_id,"long_name","TOA Brightness Temperature (Downwelling)")
  status = nf90_put_att(ncid,var_tbdn1_id,"units","K")
  status = nf90_put_att(ncid,var_tbdn1_id,"_FillValue", -999.9)

  status = nf90_put_att(ncid,var_tbup0_id,"short_name","TB_UP_GND")
  status = nf90_put_att(ncid,var_tbup0_id,"long_name","GROUND Brightness Temperature (Upwelling)")
  status = nf90_put_att(ncid,var_tbup0_id,"units","K")
  status = nf90_put_att(ncid,var_tbup0_id,"_FillValue", -999.9)

  status = nf90_put_att(ncid,var_tbdn0_id,"short_name","TB_DN_GND")
  status = nf90_put_att(ncid,var_tbdn0_id,"long_name","GROUND Brightness Temperature (Downwelling)")
  status = nf90_put_att(ncid,var_tbdn0_id,"units","K")
  status = nf90_put_att(ncid,var_tbdn0_id,"_FillValue", -999.9)

  ! Attributes for Station level variables
  status = nf90_put_att(ncid,var_te2_id,"short_name","T2m")
  status = nf90_put_att(ncid,var_te2_id,"long_name","2m Temperature")
  status = nf90_put_att(ncid,var_te2_id,"units","K")
  status = nf90_put_att(ncid,var_te2_id,"_FillValue",-999.9)

  status = nf90_put_att(ncid,var_rh2_id,"short_name","RH_s")
  status = nf90_put_att(ncid,var_rh2_id,"long_name","2m Relative humidity")
  status = nf90_put_att(ncid,var_rh2_id,"units","%")
  status = nf90_put_att(ncid,var_rh2_id,"_FillValue",-999.9)

  status = nf90_put_att(ncid,var_pr2_id,"short_name","P_s")
  status = nf90_put_att(ncid,var_pr2_id,"long_name","2m air pressure")
  status = nf90_put_att(ncid,var_pr2_id,"units","hPa")
  status = nf90_put_att(ncid,var_pr2_id,"_FillValue",-999.9)
  
  ! Attributes for Profile variables
  status = nf90_put_att(ncid,var_te_id,"short_name","temp")
  status = nf90_put_att(ncid,var_te_id,"long_name","temperature")
  status = nf90_put_att(ncid,var_te_id,"units","K")
  status = nf90_put_att(ncid,var_te_id,"_FillValue",-999.9)

  status = nf90_put_att(ncid,var_pr_id,"short_name","press")
  status = nf90_put_att(ncid,var_pr_id,"long_name","pressure")
  status = nf90_put_att(ncid,var_pr_id,"units","hPa")
  status = nf90_put_att(ncid,var_pr_id,"_FillValue",-999.9)

  status = nf90_put_att(ncid,var_rh_id,"short_name","rh")
  status = nf90_put_att(ncid,var_rh_id,"long_name","relative humidity")
  status = nf90_put_att(ncid,var_rh_id,"units","%")
  status = nf90_put_att(ncid,var_rh_id,"_FillValue",-999.9)
  
  status = nf90_put_att(ncid,var_qv_id,"short_name","qv")
  status = nf90_put_att(ncid,var_qv_id,"long_name","specific humidity")
  status = nf90_put_att(ncid,var_qv_id,"units","g m-3")
  status = nf90_put_att(ncid,var_qv_id,"_FillValue",-999.9)

  status = nf90_put_att(ncid,var_qc_id,"short_name","qc")
  status = nf90_put_att(ncid,var_qc_id,"long_name","cloud water content")
  status = nf90_put_att(ncid,var_qc_id,"units","g m-3")
  status = nf90_put_att(ncid,var_qc_id,"_FillValue",-999.9)

  status = nf90_put_att(ncid,var_qr_id,"short_name","qr")
  status = nf90_put_att(ncid,var_qr_id,"long_name","rain water content")
  status = nf90_put_att(ncid,var_qr_id,"units","g m-3")
  status = nf90_put_att(ncid,var_qr_id,"_FillValue",-999.9)
  
  status = nf90_put_att(ncid,var_qs_id,"short_name","qs")
  status = nf90_put_att(ncid,var_qs_id,"long_name","snow water content")
  status = nf90_put_att(ncid,var_qs_id,"units","g m-3")
  status = nf90_put_att(ncid,var_qs_id,"_FillValue",-999.9)

  status = nf90_put_att(ncid,var_qg_id,"short_name","qg")
  status = nf90_put_att(ncid,var_qg_id,"long_name","graupel water content")
  status = nf90_put_att(ncid,var_qg_id,"units","g m-3")
  status = nf90_put_att(ncid,var_qg_id,"_FillValue",-999.9)

  status = nf90_put_att(ncid,var_qi_id,"short_name","qi")
  status = nf90_put_att(ncid,var_qi_id,"long_name","ice water content")
  status = nf90_put_att(ncid,var_qi_id,"units","g m-3")
  status = nf90_put_att(ncid,var_qi_id,"_FillValue",-999.9)

  status = nf90_put_att(ncid,var_kexttot_id,"short_name","kext_tot")
  status = nf90_put_att(ncid,var_kexttot_id,"long_name","total extinction coefficient")
  status = nf90_put_att(ncid,var_kexttot_id,"units","km-1")
  status = nf90_put_att(ncid,var_kexttot_id,"_FillValue",-999.9)
  
  status = nf90_put_att(ncid,var_kextatm_id,"short_name","kext_atm")
  status = nf90_put_att(ncid,var_kextatm_id,"long_name","atmospheric extinction coefficient")
  status = nf90_put_att(ncid,var_kextatm_id,"units","km-1")
  status = nf90_put_att(ncid,var_kextatm_id,"_FillValue",-999.9)

  status = nf90_put_att(ncid,var_kextqc_id,"short_name","kext_cloud")
  status = nf90_put_att(ncid,var_kextqc_id,"long_name","cloud extinction coefficient")
  status = nf90_put_att(ncid,var_kextqc_id,"units","km-1")
  status = nf90_put_att(ncid,var_kextqc_id,"_FillValue",-999.9)

  status = nf90_put_att(ncid,var_kextqr_id,"short_name","kext_rain")
  status = nf90_put_att(ncid,var_kextqr_id,"long_name","rain extinction coefficient")
  status = nf90_put_att(ncid,var_kextqr_id,"units","km-1")
  status = nf90_put_att(ncid,var_kextqr_id,"_FillValue",-999.9)
  
  status = nf90_put_att(ncid,var_kextqs_id,"short_name","kext_snow")
  status = nf90_put_att(ncid,var_kextqs_id,"long_name","snow extinction coefficient")
  status = nf90_put_att(ncid,var_kextqs_id,"units","km-1")
  status = nf90_put_att(ncid,var_kextqs_id,"_FillValue",-999.9)

  status = nf90_put_att(ncid,var_kextqg_id,"short_name","kext_graupel")
  status = nf90_put_att(ncid,var_kextqg_id,"long_name","graupel extinction coefficient")
  status = nf90_put_att(ncid,var_kextqg_id,"units","km-1")
  status = nf90_put_att(ncid,var_kextqg_id,"_FillValue",-999.9)

  status = nf90_put_att(ncid,var_kextqi_id,"short_name","kext_ice")
  status = nf90_put_att(ncid,var_kextqi_id,"long_name","ice extinction coefficient")
  status = nf90_put_att(ncid,var_kextqi_id,"units","km-1")
  status = nf90_put_att(ncid,var_kextqi_id,"_FillValue",-999.9)
  
  status = nf90_put_att(ncid,var_salbtot_id,"short_name","alb_tot")
  status = nf90_put_att(ncid,var_salbtot_id,"long_name","total surface albedo")
  status = nf90_put_att(ncid,var_salbtot_id,"units","")
  status = nf90_put_att(ncid,var_salbtot_id,"_FillValue",-999.9)

  status = nf90_put_att(ncid,var_backsct_id,"short_name","backscatt")
  status = nf90_put_att(ncid,var_backsct_id,"long_name","backscattering coefficient")
  status = nf90_put_att(ncid,var_backsct_id,"units","km-1")
  status = nf90_put_att(ncid,var_backsct_id,"_FillValue",-999.9)

  status = nf90_put_att(ncid,var_gcoeff_id,"short_name","g_coeff")
  status = nf90_put_att(ncid,var_gcoeff_id,"long_name","asymetry factor")
  status = nf90_put_att(ncid,var_gcoeff_id,"units","1")
  status = nf90_put_att(ncid,var_gcoeff_id,"_FillValue",-999.9)


  ! ***** Grid variables 
  status = nf90_put_att(ncid,var_xid,"short_name","Xn")
  status = nf90_put_att(ncid,var_xid,"long_name","X_grid")
  status = nf90_put_att(ncid,var_yid,"short_name","Yn")
  status = nf90_put_att(ncid,var_yid,"long_name","Y_grid")

  status = nf90_put_att(ncid,var_elvid,"short_name","ELV")
  status = nf90_put_att(ncid,var_elvid,"long_name","Elevation")
  status = nf90_put_att(ncid,var_elvid,"units","km")

  status = nf90_put_att(ncid,var_latid,"short_name","LAT")
  status = nf90_put_att(ncid,var_latid,"long_name","Latitude")
  status = nf90_put_att(ncid,var_latid,"units","DEG")
  
  status = nf90_put_att(ncid,var_lonid,"short_name","LON")
  status = nf90_put_att(ncid,var_lonid,"long_name","Longitude")
  status = nf90_put_att(ncid,var_lonid,"units","DEG")

  status = nf90_put_att(ncid,NF90_GLOBAL,"Input_data", input_file)
  status = nf90_put_att(ncid,NF90_GLOBAL,"Wyosonde_station", trim(origin_str))
  status = nf90_put_att(ncid,NF90_GLOBAL,"Hydrometeor_Microphysics", micro_phys)
  status = nf90_put_att(ncid,NF90_GLOBAL,"Contact","Pablo.Saavedra@uib.no")
  status = nf90_put_att(ncid,NF90_GLOBAL,"Institution","Geophysical Institute, University of Bergen")

  ! End definitions
  status = nf90_enddef(ncid)
  
  ! Putting variables independent of time:
  stokes_var = (/(I,I=1,NSTOKES)/)
  !TIMELINE = -999.9
  status = nf90_put_var(ncid, var_lyr_id, LAYERS)
  status = nf90_put_var(ncid, var_freq_id, freq_str)
  status = nf90_put_var(ncid, var_stok_id, stokes_var)
  !status = nf90_put_var(ncid, var_time_id, TIMELINE)
  status = nf90_put_var(ncid, var_elvid, SELV)
  status = nf90_put_var(ncid, var_latid, SLAT)
  status = nf90_put_var(ncid, var_lonid, SLON)
  
  status = nf90_close(ncid)
  if (status /= NF90_NOERR) stop 'Error closing after creation NetCDF file!'
end subroutine createncdf
! ___________________________________________________________________________


! ____________________________________________________________________________
! ----------------------------------------------------------------------------
! SUBROUTINE to store the RT3/4 data in the created NetCDF output file
!
! ----------------------------------------------------------------------------
subroutine storencdf(OUT_FILE,MU_VALUES,NUMMU,HEIGHT,NOUTLEVELS,OUTVAR,NSTOKES,time_len)
  use netcdf
  use, intrinsic :: iso_c_binding
  
  implicit none

  ! Interface to the C code for Unix time retrieval:
  interface
     function F2UnixTime(datum) result(val) bind(c, name='F2UnixTime')
       use, intrinsic :: iso_c_binding
       integer(kind=c_int) :: datum(6)
       real(kind=c_double) :: val
     end function F2UnixTime
  end interface
  
  character(len=*), intent(in) :: OUT_FILE
  real(kind=8), intent(in) :: MU_VALUES(NUMMU), HEIGHT(NOUTLEVELS), OUTVAR(NUMMU,NSTOKES,2,NOUTLEVELS)
  integer, intent(in) :: NUMMU, NOUTLEVELS, NSTOKES, time_len

  ! internal variables
  integer :: i, j, k
  integer :: status, ncid, VarId, idx, idf
  integer :: nDims, unlimdimid, freq_id
  character(len=len(OUT_FILE)+3) :: ncfile
  character(len=40) :: dim_name
  integer :: x_grid, y_grid, i_freq, freq_len, NTIME
  real(kind=8) :: AllFreq(30)
  real(kind=8), allocatable, dimension(:) :: ZENITH_THTA  ! (NUMMU)
  real(kind=8), allocatable, dimension(:,:,:,:) :: TB_THTA
  real(kind=8), allocatable, dimension(:) :: elevations, elvmu
  real(kind=c_double) :: TIMELINE
  integer(kind=c_int) :: date(6)
  real(kind=8), parameter :: PI = 4.0*atan(1.0)
  integer :: nelv, NANG
  
  namelist/mwrobsang/nelv,elevations
  

  ! Extracting information from the OUT_FILE character string:
  ! * The OUT_FILE has the form like:
  ! ../output/TB/RT3TB13090112Exp7.6MaxGa0.2Exp4.0MaxGaExp8.0x001y001f27.20
  !
  ! which needs to be transformed to a NetCDF file like:
  ! ../output/TB/RT3TB_Exp7.6MaxGa0.2Exp4.0MaxGaExp8.0_f27.2.nc

  ! * grid indices:
  idx = scan(OUT_FILE,'x',back=.true.)+1
  if(idx.eq.1) stop 'no x000_ found in string passed'
  read(OUT_FILE(idx:),'(I03XI03)') x_grid, y_grid

  ! * Date and * getting microphysics from OUT_FILE:
  date = 0
  idx = scan(OUT_FILE,'=',back=.true.)+1
  if(idx.eq.1) stop 'no separator = found in string passed'
  idf = scan(OUT_FILE,'x',back=.true.)
  read(OUT_FILE(idx:idf-1),'(4I02)') date(1:4) !, micro_phys  ! '(5X4I02A)'
  date(1) = date(1)+2000
  TIMELINE = F2UnixTime(date)

  ! constructing netCDF file to write data:
  idf = scan(OUT_FILE,'=',back=.true.)-1
  ncfile = OUT_FILE(:idf)

  status = NF90_OPEN(ncfile,MODE=NF90_WRITE,NCID=ncid)
  if(status/=NF90_NOERR) stop 'Opening the NetCDF to add in STORENCDF()'

  ! Getting NetCDF file dimensions and lengths:
  ! For time:
  !!!status = nf90_inquire(ncid, nDimensions = nDims,unlimitedDimID = unlimdimid)
  status = nf90_inq_varid(ncid,"time",unlimdimid)
  status = nf90_inquire_dimension(ncid,unlimdimid,dim_name, NTIME)
  !!!allocate(TIMELINE(time_len))
  !!!status = nf90_get_var(ncid,unlimdimid,TIMELINE)
  !!!time_len = minloc(TIMELINE,MASK=TIMELINE.LT.0)

  ! For frequency
  ! * Frequency from OUT_FILE:
  idx = scan(OUT_FILE,'f',back=.true.)+1
  read(OUT_FILE(idx:),'(I6)') i_freq

  AllFreq = -999.
  status = nf90_inq_varid(ncid,"freq",freq_id)
  status = nf90_inquire_dimension(ncid,freq_id,dim_name,freq_len)
  status = nf90_get_var(ncid,freq_id,AllFreq(1:freq_len))

  if(i_freq.LT.1) stop 'ERROR finding frequency index in STORENCDF'
  print*, 'Date, UXTIME, x-grid, y-grid, freq dim has: ',date, TIMELINE, x_grid, y_grid, AllFreq(i_freq)
  
  ! Writting variable values ZENITH_THTA into NetCDF file:
  status = nf90_inq_varid(ncid, "theta_z", VarId)
  if(status /= nf90_NoErr)  stop 'cos(MU) ID cannot be assigned!'
  status = nf90_inquire_dimension(ncid,VarId,dim_name,NANG)
  status = nf90_get_att(ncid,VarID,"N_obs_angles",nelv)

  allocate(ZENITH_THTA(NANG))
  allocate(TB_THTA(NANG,NSTOKES,2,NOUTLEVELS))
  allocate(elevations(nelv))
  allocate(elvmu(nelv))

  status = nf90_get_att(ncid,VarId,"Obs_angles_degree",elevations)
  
  ! converting input MWR elevation angles into zenithal angles cos(pi/2-mu)
  elvmu = cos((90.0-elevations)*PI/180.)

  ! Checking whether additional observation angles are needed:
  if(nelv.GT.0) then
     ! Interpolate the values for the additional angles:
     CALL interp1_1D(MU_VALUES, OUTVAR, NUMMU, elvmu, nelv,&
          & ZENITH_THTA, NANG, TB_THTA, NSTOKES,2,NOUTLEVELS)
  else
     ! No additional angles, only simulations:
     ZENITH_THTA(:NANG) = MU_VALUES(:NUMMU)
  end if
  
  if(time_len.EQ.1.AND.i_freq.EQ.1) then
     ! converting cos(mu) to zenithal angle:
     ZENITH_THTA = acos(ZENITH_THTA)*180.0/PI
     status = nf90_put_var(ncid,VarId,ZENITH_THTA(:NANG))
     if(status /= nf90_NoErr) stop 'cos(MU) values cannot be stored!'


     ! writting Initial date as global variable:
     status = nf90_redef(ncid)
     status = nf90_put_att(ncid,NF90_GLOBAL,"Start_Date", date) !OUT_FILE(19:26))
     status = nf90_enddef(ncid)

  end if
  
  if(time_len.GT.1.AND.i_freq.EQ.freq_len) then
     ! writting Initial date as global variable:
     status = nf90_redef(ncid)
     status = nf90_put_att(ncid,NF90_GLOBAL,"End_Date", date) !OUT_FILE(19:26))  ! (16:23)
     status = nf90_enddef(ncid)
  end if
  
  ! writing time
  ! writting TB_UPwelling
  status = nf90_inq_varid(ncid, "time", VarId)
  if(status /= nf90_NoErr) stop 'Time cannot be assigned!'
  status = nf90_put_var(ncid,VarId,TIMELINE,start=(/time_len/))  ! date(3)
  if(status /= nf90_NoErr) stop 'Time values cannot be stored!'

  ! writting TOA TB_UPwelling ( OUTVAR has the dimension of [mu,stokes,Xwelling,level]) 
  status = nf90_inq_varid(ncid, "TB_UP_TOA", VarId)
  if(status /= nf90_NoErr) stop 'TB_UP TOA cannot be assigned!' ! OUTVAR(:,:,1,1)
  status = nf90_put_var(ncid,VarId,TB_THTA(:NANG,:,1,1),start=(/1,i_freq,1,x_grid,y_grid,time_len/),count=(/NANG,1,2,1,1,1/))
  !status = nf90_put_var(ncid,VarId,OUTVAR(:,:,1,:),start=(/1,1,1,x_grid,y_grid,time_len/),count=(/NUMMU,2,NOUTLEVELS,1,1,1/))
  if(status /= nf90_NoErr) stop 'TB_UP TOA values cannot be stored!'
  
  ! writting TOA TB_DOWNwelling
  status = nf90_inq_varid(ncid, "TB_DN_TOA", VarId)
  if(status /= nf90_NoErr) stop 'TB_DN TOA cannot be assigned!' ! OUTVAR(:,:,2,1)
  !status = nf90_put_var(ncid,VarId,OUTVAR(:,:,2,:),start=(/1,1,1,time_len/),count=(/NUMMU,2,NOUTLEVELS,1/))
  status = nf90_put_var(ncid,VarId,TB_THTA(:NANG,:,2,1),start=(/1,i_freq,1,x_grid,y_grid,time_len/),count=(/NANG,1,2,1,1,1/))
  if(status /= nf90_NoErr) stop 'TB_DN TOA values cannot be stored!'
  
  ! writting GROUND TB_UPwelling ( OUTVAR has the dimension of [mu,stokes,Xwelling,level]) 
  status = nf90_inq_varid(ncid, "TB_UP_GRD", VarId)
  if(status /= nf90_NoErr) stop 'TB_UP GRD cannot be assigned!'
  status = nf90_put_var(ncid,VarId,TB_THTA(:NANG,:,1,2),start=(/1,i_freq,1,x_grid,y_grid,time_len/),count=(/NANG,1,2,1,1,1/))
  !status = nf90_put_var(ncid,VarId,OUTVAR(:,:,1,:),start=(/1,1,1,x_grid,y_grid,time_len/),count=(/NUMMU,2,NOUTLEVELS,1,1,1/))
  if(status /= nf90_NoErr) stop 'TB_UP GRD values cannot be stored!'
  
  ! writting GROUND TB_DOWNwelling
  status = nf90_inq_varid(ncid, "TB_DN_GRD", VarId)
  if(status /= nf90_NoErr) stop 'TB_DN GRD cannot be assigned!'
  !status = nf90_put_var(ncid,VarId,OUTVAR(:,:,2,:),start=(/1,1,1,time_len/),count=(/NUMMU,2,NOUTLEVELS,1/))
  status = nf90_put_var(ncid,VarId,TB_THTA(:NANG,:,2,2),start=(/1,i_freq,1,x_grid,y_grid,time_len/),count=(/NANG,1,2,1,1,1/))
  if(status /= nf90_NoErr) stop 'TB_DN GRD values cannot be stored!'
    
  ! writting x_grid and y grid indexes:
  status = nf90_inq_varid(ncid,"xn", VarId)
  status = nf90_put_var(ncid,VarId,x_grid)
  status = nf90_inq_varid(ncid,"yn", VarId)
  status = nf90_put_var(ncid,VarId,y_grid)
  
  status = NF90_CLOSE(ncid)
  if (status /= NF90_NOERR) stop 'Closing NetCDF was not possible!'

  if(allocated(ZENITH_THTA)) deallocate(ZENITH_THTA)
  if(allocated(TB_THTA)) deallocate(TB_THTA)
  if(allocated(elevations)) deallocate(elevations)
  if(allocated(elvmu)) deallocate(elvmu)

  return
  
end subroutine storencdf
!  if(status /= NF90_NoErr) stop 'Creating the NetCDF to write!'


! ____________________________________________________________________________
! ----------------------------------------------------------------------------
! SUBROUTINE Microphysics variable storege for the RT3/4 NetCDF output file
!
! ----------------------------------------------------------------------------
subroutine MP_storencdf(OUT_FILE,time_len,i_freq,y_grid,x_grid,NLYR,LAYERS,TEMP,PRESS,RH,QV,QC,&
     &KEXTQC,KEXTATM,KEXTTOT,ALBEDO,BACKSCATT,GCOEFF)
  use netcdf

  implicit none

  character(len=*), intent(in) :: OUT_FILE
  integer, intent(in) :: time_len, i_freq, y_grid, x_grid, NLYR
  real(kind=8), intent(in) :: TEMP(0:NLYR), PRESS(0:NLYR), RH(0:NLYR)  ! 0: because surface values
  real(kind=8), intent(in) :: LAYERS(NLYR), QV(NLYR),QC(NLYR)
  real(kind=8), intent(in) :: KEXTTOT(NLYR), KEXTATM(NLYR), KEXTQC(NLYR)
  real(kind=8), intent(in) :: ALBEDO(NLYR), BACKSCATT(NLYR), GCOEFF(NLYR)

  ! internal variables
  integer :: status, ncid, VarId
  integer :: nDims, unlimdimid, freq_id
  character(len=len(OUT_FILE)+3) :: ncfile
  character(len=30) :: dim_name
  real(kind=8) :: AllFreq(30), freq
  integer :: freq_len

  ncfile = OUT_FILE
  status = NF90_OPEN(ncfile,MODE=NF90_WRITE,NCID=ncid)
  if(status/=NF90_NOERR) stop 'Opening the NetCDF to add'

  ! Getting NetCDF file dimensions and lengths:

  ! For frequency:
  AllFreq = -99.
  status = nf90_inq_varid(ncid,"freq",freq_id)
  status = nf90_inquire_dimension(ncid,freq_id,dim_name,freq_len)
  status = nf90_get_var(ncid,freq_id,AllFreq(1:freq_len))

  if(i_freq.LT.1) stop 'ERROR: finding the frequency index in NP_STORENCDF'
  
  ! ********** Writting Station level Variables ****************************
  ! Writting the 2m Temperature
  status = nf90_inq_varid(ncid, "T2m", VarId)
  if(status /= nf90_NoErr) stop 'T2m variable ID cannot be read!'
  status = nf90_put_var(ncid,VarId, TEMP(0:0), start=(/1,1,time_len/), count=(/1,1,1/))
  if(status /= nf90_NoErr) stop 'T2m variable cannot be written!'

  ! Writting the 2m RH
  status = nf90_inq_varid(ncid, "RH2m", VarId)
  if(status /= nf90_NoErr) stop 'RH2m variable ID cannot be read!'
  status = nf90_put_var(ncid, VarId, RH(0:0),  start=(/1,1,time_len/), count=(/1,1,1/))
  
  ! Writting the 2m Air Pressure
  status = nf90_inq_varid(ncid, "P2m", VarId)
  if(status /= nf90_NoErr) stop 'Air pressure variable ID cannot be read!'
  status = nf90_put_var(ncid, VarId, PRESS(0:0),  start=(/1,1,time_len/), count=(/1,1,1/))
  
  ! ********** Writting Profile Variables ****************************
  ! Writting the Temperature
  status = nf90_inq_varid(ncid, "temp", VarId)
  if(status /= nf90_NoErr) stop 'Temperature profile ID cannot be read!'
  status = nf90_put_var(ncid, VarId, TEMP, start=(/1,1,1,time_len/),count=(/1,1,NLYR,1/))
  if(status /= nf90_NoErr) stop 'Temperature profile cannot be written!'

  ! Writting the Pressure
  status = nf90_inq_varid(ncid, "press", VarId)
  if(status /= nf90_NoErr) stop 'Pressure profile ID cannot be read!'
  status = nf90_put_var(ncid, VarId, PRESS, start=(/1,1,1,time_len/),count=(/1,1,NLYR,1/))
  if(status /= nf90_NoErr) stop 'Pressure profile cannot be written!'

  ! Writting the Relative Humidity
  status = nf90_inq_varid(ncid, "rh", VarId)
  if(status /= nf90_NoErr) stop 'RH profile ID cannot be read!'
  status = nf90_put_var(ncid, VarId, RH, start=(/1,1,1,time_len/),count=(/1,1,NLYR,1/))
  if(status /= nf90_NoErr) stop 'RH profile cannot be written!'

  ! Writting the QV variable
  status = nf90_inq_varid(ncid, "qv", VarId)
  if(status /= nf90_NoErr) stop 'QV variable ID cannot be read!'
  status = nf90_put_var(ncid, VarId, QV, start=(/1,1,1,time_len/),count=(/1,1,NLYR,1/))
  if(status /= nf90_NoErr) stop 'QV cannot be written!'
  ! Writting the QC variable
  status = nf90_inq_varid(ncid, "qc", VarId)
  if(status /= nf90_NoErr) stop 'QC variable ID cannot be read!'
  status = nf90_put_var(ncid, VarId, QC, start=(/1,1,1,time_len/),count=(/1,1,NLYR,1/))
  if(status /= nf90_NoErr) stop 'QC cannot be written!'
  ! Writting the ATMOSPHERIC Extintion coeff
  status = nf90_inq_varid(ncid, "kext_atm", VarId)
  if(status /= nf90_NoErr) stop 'KEXT_ATMOS variable ID cannot be read!'
  status = nf90_put_var(ncid, VarId, KEXTATM, start=(/1,1,1,i_freq,time_len/),count=(/1,1,NLYR,1,1/))
  if(status /= nf90_NoErr) stop 'KEXT_ATMOS cannot be written!'
! Writting the Cloud Extintion coeff
  status = nf90_inq_varid(ncid, "kext_qc", VarId)
  if(status /= nf90_NoErr) stop 'KEXT_CLOUD variable ID cannot be read!'
  status = nf90_put_var(ncid, VarId, KEXTQC, start=(/1,1,1,i_freq,time_len/),count=(/1,1,NLYR,1,1/))
  if(status /= nf90_NoErr) stop 'KEXT_CLOUD cannot be written!'
! Writting the Total Extintion coeff
  status = nf90_inq_varid(ncid, "kext_tot", VarId)
  if(status /= nf90_NoErr) stop 'KEXT_TOTAL variable ID cannot be read!'
  status = nf90_put_var(ncid, VarId, KEXTTOT, start=(/1,1,1,i_freq,time_len/),count=(/1,1,NLYR,1,1/))
  if(status /= nf90_NoErr) stop 'KEXT_TOT cannot be written!'

  ! Writting the Total Albedo coeff
  status = nf90_inq_varid(ncid, "alb_tot", VarId)
  if(status /= nf90_NoErr) stop 'TOTAL Albedo variable ID cannot be read!'
  status = nf90_put_var(ncid, VarId, ALBEDO, start=(/1,1,1,i_freq,time_len/),count=(/1,1,NLYR,1,1/))
  if(status /= nf90_NoErr) stop 'TOTAL  ALBEDO cannot be written!'

  ! Writting the Backscattering coeff
  status = nf90_inq_varid(ncid, "back_scatt", VarId)
  if(status /= nf90_NoErr) stop 'Backscattering variable ID cannot be read!'
  status = nf90_put_var(ncid, VarId, BACKSCATT, start=(/1,1,1,i_freq,time_len/),count=(/1,1,NLYR,1,1/))
  if(status /= nf90_NoErr) stop 'Backscattering cannot be written!'

  ! Writting the asymetry factor
  status = nf90_inq_varid(ncid, "g_coeff", VarId)
  if(status /= nf90_NoErr) stop 'G-factor variable ID cannot be read!'
  status = nf90_put_var(ncid, VarId, GCOEFF, start=(/1,1,1,i_freq,time_len/),count=(/1,1,NLYR,1,1/))
  if(status /= nf90_NoErr) stop 'G-factor cannot be written!'
  
  status = NF90_CLOSE(ncid)
  if (status /= NF90_NOERR) stop 'Closing NetCDF was not possible!'
  return
end subroutine MP_storencdf
! _____________________________________________________________________________________


! -------------------------------------------------------------------------------------
! Subroutine to interpolate extra observations angles
! in case the input value is out of limits, extrapolation is attended with the two first
! (lower extrapolation) or last (upper extrapolation) values of the vector.
!
subroutine interp1_1D(Xin, Yin, Nin, X0, N0, Xout, Nout, Yout, Nstk, Nflx, Nlev)
  
  ! Interpolated abssice values must increase monotonically, 
  ! the ordenate values can be decreasing or increasing
  ! Repeated values in Xin and X0 are omitted
  
  implicit none
  integer, intent(in) :: Nin, N0, Nstk, Nflx, Nlev, Nout
  real(kind=8), intent(in) :: Xin(Nin), X0(N0), Yin(Nin,Nstk,Nflx,Nlev)
  real(kind=8), intent(out):: Xout(Nout)
  real(kind=8), intent(out):: Yout(Nout,Nstk,Nflx,Nlev)
  integer :: h, idx, idn, iout
  real(kind=8) :: a, b, Fa(Nstk, Nflx, Nlev), Fb(Nstk, Nflx, Nlev), F0(Nstk, Nflx, Nlev)
  real(kind=8) :: eps = 1.0E-4
  
  ! union of Xin and X0 sets
  Yout = -69.8
  Yout(1:Nin,:,:,:) = Yin
  
  Xout = -69.0
  Xout(1:Nin) = Xin
    
  do h = 1, N0
     !if(any(abs(Xout-X0(h)).LT.eps)) cycle
     !iout = iout + 1
     if(X0(h).GT.maxval(Xout)) then
        idx = maxloc(Xout,1)+1
        a = Xout(idx-2)
        b = Xout(idx-1)
        Fa = Yout(idx-2,:,:,:)
        Fb = Yout(idx-1,:,:,:)
     else if(X0(h).LT.minval(Xout)) then
        idx = 1
        a = Xout(idx)
        b = Xout(idx+1)
        Fa = Yout(idx,:,:,:)
        Fb = Yout(idx+1,:,:,:)
     else
        idx = minloc(Xout,DIM=1,MASK=X0(h)<=Xout)
        a = Xout(idx-1)
        b = Xout(idx)
        Fa = Yout(idx-1,:,:,:)
        Fb = Yout(idx,:,:,:)
     end if
     
     if(abs(X0(h)-b).LT.eps) then
        F0 = Fb
     else if(abs(X0(h)-a).LT.eps) then
        F0 = Fa
     else
        F0 = Fa + (X0(h)-a)*(Fb-Fa)/(b-a)
     end if
     idn = Nin+h-1
     Xout(idx+1:idn+1) = Xout(idx:idn)
     Xout(idx) = X0(h)

     Yout(idx+1:idn+1, :, :, :) = Yout(idx:idn,:,:,:)
     Yout(idx, :, :, :)   = F0
     
  end do
  
end subroutine interp1_1D

