! *****************************************************************************************
! Set of subroutines to manage netCDF input/output files.
! -----------------------------------------------------------------------------------------
! * read_wrf     : read netCDF files from WRF output files,
! * read_wyosonde: read netCDF files from radiosondes with homoginized layers,
! * createncdf   : create and setup variables and dimensions for RT output files,
! * storencdf    : save the TB variables into the previous created netCDF file,
! * MP_storencdf : save the microphysics variables into the created netCDF file.
!
! (c) 2018 Pablo Saavedra G. (pablo.saa@uib.no)
! Geophysical Institute, University of Bergen
! SEE LICENSE.TXT
! --------------------------------------------------------------------------------------

! ______________________________________________________________________________________
! --------------------------------------------------------------------------------------
! Subroutine to read WRF simulation outputs from NetCDF-file generated by standard
! WRF code.
!
! The loaded variables are introduced to the RT3/RT4 radiative transfer code for
! calculation of Brightness Temperature Fields.
! -------------------------------------------------------------------------------------
subroutine read_wrf(ncflen, ncfile, del_xy, origin_str)
  use netcdf
  use variables
  
  implicit none

  integer, intent(in) :: ncflen
  character(len=ncflen), intent(in) :: ncfile

  ! -- Here come variables declaration alike the onses used by RT3
  real(kind=4), intent(out) :: del_xy(2)
  character(len=*), intent(out) :: origin_str

  ! -- end of variable declaration

  integer :: status
  integer :: ncid, ndims_in, nvars_in, ngatts_in, unlimdimid_in
  integer :: VarId
  character(len=15), allocatable :: dim_name(:)
  character(len=30) :: varname
  integer :: i, j, k, NN
  integer, allocatable, dimension(:) :: myVarIDs, dim_len
  
  real(kind=8), allocatable, dimension(:,:,:,:) :: U_Vel, V_Vel, mixratio
  character(len=15), dimension(18) :: wrfvarname

  ! List of variable names to load (WRF convention)
  wrfvarname(1) = 'T2'
  wrfvarname(2) = 'PSFC'
  wrfvarname(3) = 'Q2'
  wrfvarname(4) = 'XLAT'
  wrfvarname(5) = 'XLONG'
  wrfvarname(6) = 'PHB'
  wrfvarname(7) = 'P_HYD'
  wrfvarname(8) = 'T'
  wrfvarname(9) = 'QVAPOR'
  wrfvarname(10) = 'QCLOUD'
  wrfvarname(11) = 'QRAIN'
  wrfvarname(12) = 'QICE'
  wrfvarname(13) = 'QSNOW'
  wrfvarname(14) = 'QGRAUP'
  wrfvarname(15) = 'V'
  wrfvarname(16) = 'U'
  wrfvarname(17) = 'Times'
  wrfvarname(18) = 'QXI'

  ! -----------------------------------------------------------------------------
  ! Open file and read directory
  print*,'WRF netCDF input files is', ncflen, ' : ', trim(ncfile)
  
  status = nf90_open(ncfile,NF90_NOWRITE,ncid)
  if(status.ne.0) then
     print*, 'Cannot open netCDF-file: '//trim(ncfile)
     stop
  end if
  status = nf90_inquire(ncid, ndims_in, nvars_in, ngatts_in, unlimdimid_in)
  ! Get ID of unlimited dimension

  allocate(dim_len(ndims_in), dim_name(ndims_in) )

  do i=1, ndims_in
     ! assigning dimension name and length:
     status = nf90_inquire_dimension(ncid,i,dim_name(i), dim_len(i))
     select case(trim(dim_name(i)))
     case('west_east')
        ngridx = dim_len(i)
     case('south_north')
        ngridy = dim_len(i)
     case('bottom_top')
        nlyr = dim_len(i)
     case('Time')
        ntime = dim_len(i)
     case('DateStrLen')
        NN = dim_len(i)
     case default
        print*, 'netCDF file dimension '//trim(dim_name(i))//' unknown!'
        ! stop
     end select
  end do
  allocate( character(len=NN) :: TimeStamp(ntime) )
  
  allocate(myVarIDs(nvars_in))
  status = nf90_inq_varids(ncid, nvars=NN, varids=myVarIDs)

  ! ALLOCATING VARIABLES with netCDF dimensions:
  allocate( hgt_tmp(ngridx, ngridy, 0:nlyr, ntime) )
  allocate( temp_tmp(ngridx, ngridy, 0:nlyr, ntime) )
  allocate( press_tmp(ngridx, ngridy, 0:nlyr, ntime) )
  allocate( relhum_tmp(ngridx, ngridy, 0:nlyr, ntime) )
  allocate( mixr_tmp(ngridx, ngridy, nlyr, ntime) )
  allocate( cloud_water_tmp(ngridx, ngridy, nlyr, ntime) )
  allocate( rain_water_tmp(ngridx, ngridy, nlyr, ntime) )
  allocate( cloud_ice_tmp(ngridx, ngridy, nlyr, ntime) )
  allocate( snow_tmp(ngridx, ngridy, nlyr, ntime) )
  allocate( graupel_tmp(ngridx, ngridy, nlyr, ntime) )
  allocate( windvel_tmp(ngridx, ngridy, nlyr, ntime) )
  allocate( winddir_tmp(ngridx, ngridy, nlyr, ntime) )
  allocate( lat(ngridx, ngridy),  lon(ngridx, ngridy) )
  allocate( qidx(ngridx, ngridy, ntime) )
  
  ! For local variables:
  allocate(mixratio(ngridx, ngridy, 0:nlyr, ntime) )
  allocate(U_Vel(ngridx, ngridy, nlyr, ntime) )
  allocate(V_Vel(ngridx, ngridy, nlyr, ntime) )

  ! Initialazing the variables to a fixed value
  press_tmp = 0.0d0
  temp_tmp = 0.0d0
  relhum_tmp = 0.0d0
  qidx = 15

  ! loop over all variables needed from WRF netCDF file
  do i=1, size(wrfvarname)
     status = nf90_inq_varid(ncid, trim(wrfvarname(i) ), VarId)
     if(status /= nf90_NoErr) then
        print*, 'WARNING: variable ',trim(wrfvarname(i)),' cannot be read: ', nf90_strerror(status)
        cycle
     end if
     select case(trim(wrfvarname(i) ))
        ! *** Reading for WRF SURFACE variables:
     case('T2')
        status = nf90_get_var(ncid, VarId, temp_tmp(:, :, 0, :))
     case('PSFC')
        status = nf90_get_var(ncid, VarId, press_tmp(:, :, 0, :))
     case('Q2')
        status = nf90_get_var(ncid, VarId, mixratio(:, :, 0, :))
     case('XLAT')
        status = nf90_get_var(ncid, VarId, lat, start=(/1,1,1/), count=(/ngridx, ngridy, 1/))
     case('XLONG')
        status = nf90_get_var(ncid, VarId, lon, start=(/1,1,1/), count=(/ngridx, ngridy, 1/))
        ! *** Reading for WRF PROFILE variables:
     case('PHB')
        status = nf90_get_var(ncid, VarId, hgt_tmp)
        hgt_tmp = 1.0E-3*hgt_tmp/9.81  ! [km]
     case('P_HYD')
        status = nf90_get_var(ncid, VarId, press_tmp(:, :, 1:nlyr, :))
        press_tmp = press_tmp*1E-2  ! [hPa]
     case('T')
        status = nf90_get_var(ncid, VarId, temp_tmp(:, :, 1:nlyr, :))
     case('QVAPOR')
        status = nf90_get_var(ncid, VarId, mixratio(:, :, 1:nlyr, :))
     case('QCLOUD')
        status = nf90_get_var(ncid, VarId, cloud_water_tmp)
     case('QRAIN')
        status = nf90_get_var(ncid, VarId, rain_water_tmp)
     case('QICE')
        status = nf90_get_var(ncid, VarId, cloud_ice_tmp)
     case('QSNOW')
        status = nf90_get_var(ncid, VarId, snow_tmp)
     case('QGRAUP')
        status = nf90_get_var(ncid, VarId, graupel_tmp)
     case('V')
        status = nf90_get_var(ncid, VarId, V_Vel, start=(/1,2,1,1/) )
     case('U')
        status = nf90_get_var(ncid, VarId, U_Vel, start=(/2,1,1,1/) )
     case('Times')
        status = nf90_get_var(ncid, VarId, TimeStamp)
     case('QXI')
        status = nf90_get_var(ncid, VarId, qidx)
        print*, 'QXI assigned?!?!?'
     case default
        print*, 'WARNING: WRF variable ', trim(varname),' not recognized.'
     end select
  end do


  ! ---
  ! Variables not present in WRF:
  ! 1) Converting Perturbation Potential Temperature to Temperature:
  call PERTHETA2T(ngridx, ngridy, nlyr, ntime, temp_tmp(:, :, 1:nlyr, :),&
       & press_tmp(:, :, 1:nlyr, :), temp_tmp(:, :, 1:nlyr, :) )

  ! 2) Converting Vapor mixing ratio to Relative Humidity
  call mixr2rh(ngridx, ngridy, 1+nlyr, ntime,&
       & mixratio, press_tmp, temp_tmp, relhum_tmp)
  mixr_tmp = 1E3*mixratio(:, :, 1:nlyr, :)

  ! 3) Converting Wind U and V components to Windspeed and Direction:
  windvel_tmp(:ngridx, :ngridy, :nlyr, :ntime) = sqrt( U_Vel*U_Vel + V_Vel*V_Vel)
  winddir_tmp(:ngridx, :ngridy, :nlyr, :ntime) = modulo(360.0 - atan2(U_Vel, V_Vel)*PI2deg, 360.0)

  !do k=1,mxgridx
  !   read(TimeStamp(k), '(F4.0X1F2.0X1F2.0X1F2.0)') year(k), month(k), day(k), hour(k)
  !   write(*,'(A20X4F6.1)') TimeStamp(k), year(k), month(k), day(k), hour(k)
    
           !write(*,'(10F9.3)') (windvel_tmp(k,j,5,1), j=1,mxgridy)
  !enddo

  !  print*, 'Just read Pressure 2m:'
  ! NN=4
  !      do k=1,NN
  !        write(*,'(10F9.3)') (winddir_tmp(k,j,1,2), j=1,NN)
  !    enddo


  ! ****************************
  ! Retrieving Global Attribute:
  status = nf90_get_att(ncid,NF90_GLOBAL, 'DX', del_xy(1))
  status = nf90_get_att(ncid,NF90_GLOBAL, 'DY', del_xy(2))
  status = nf90_get_att(ncid,NF90_GLOBAL, 'TITLE', varname)
  write(origin_str,'(A)')  trim(varname)//'->'//trim(ncfile)
  
  ! ****************************
  ! Closing the NetCDF file
  status = nf90_close(ncid)
  
  deallocate(myVarIDs, dim_name, dim_len, U_Vel, V_Vel, mixratio)
  
  return
end subroutine read_wrf
! ____________________________________________________________________________
! ____________________________________________________________________________


! ______________________________________________________________________________________
! --------------------------------------------------------------------------------------
! Subroutine to read Wyoming Radiosonde database from the NetCDF-file generated by the
! code in repository github.com/pablosaa/WyoSondes
!
! The loaded variables are introduced to the RT3/RT4 radiative transfer code for
! calculation of Brightness Temperature Fields.
! -------------------------------------------------------------------------------------
subroutine read_wyosonde(ncflen,ncfile,mxgridx,mxgridy,mxlyr,mxtime,hgt_lev,&
     &press_lev,temp_lev,relhum_lev,mixr_lev, cloud_water_lev,&
     &rain_water_lev,cloud_ice_lev,snow_lev,graupel_lev, winddir_lev, windvel_lev,&
     &qidx, ngridx, ngridy, del_xy, nlyr, ntime, lat, lon, year, month, day, hour,&
     &origin_str)
  use netcdf
  implicit none

  integer, intent(in) :: ncflen
  character(len=ncflen), intent(in) :: ncfile

  ! -- Here come variables declaration alike the onses used by RT3

  integer, intent(in) ::   mxgridx, mxgridy, mxlyr, mxtime
  real(kind=8), intent(inout), dimension(mxgridx,mxgridy,0:mxlyr,mxtime) :: hgt_lev,temp_lev,press_lev,relhum_lev
  real(kind=8), intent(inout), dimension(mxgridx,mxgridy,mxlyr,mxtime) :: mixr_lev, cloud_water_lev,rain_water_lev,cloud_ice_lev
  real(kind=8), intent(inout), dimension(mxgridx,mxgridy,mxlyr,mxtime) :: snow_lev,graupel_lev, winddir_lev, windvel_lev
  integer(kind=4), intent(inout), dimension(mxgridx,mxgridy,mxtime) :: qidx
  integer, intent(out) :: ngridx, ngridy, nlyr, ntime
  real(kind=4), intent(out), dimension(mxgridx, mxgridy) :: lat, lon
  real(kind=4), intent(out), dimension(mxgridx, mxgridy, mxtime) :: year, month, day, hour
  real(kind=4), intent(out) :: del_xy(2)
  character(len=*), intent(out) :: origin_str
  ! -- end of variable declaration

  integer :: status
  integer :: ncid, ndims_in, nvars_in, ngatts_in, unlimdimid_in
  integer :: VarId
  character(len=10) :: dim_name(4)
  character(len=10) :: varname
  integer :: i, NN, dim_len(4)
  integer, allocatable, dimension(:) :: myVarIDs
  real, allocatable, dimension(:,:,:,:) :: Var4D
  real, allocatable, dimension(:,:,:) :: Var3D
  real, allocatable, dimension(:,:) :: Var2D
  real, allocatable, dimension(:) :: Var1D

  ! Initialazing the variables to a fixed value
  hgt_lev = 0.
  temp_lev =0.
  press_lev = 0.
  relhum_lev = 0.
  cloud_water_lev = 0.
  rain_water_lev = 0.
  cloud_ice_lev = 0.
  snow_lev = 0.
  graupel_lev = 0.
  lat = 0.
  lon = 0.
  year = 0.
  month = 0.
  day = 0.
  hour = 0.

  ! -----------------------------------------------------------------------------
  ! Open file and read directory
  print*,'netCDF input files is', ncflen, ' : ', ncfile
  
  status = nf90_open(ncfile,NF90_NOWRITE,ncid)
  if(status.ne.0) then
     print*, 'Cannot open netCDF-file: '//trim(ncfile)
     stop
  end if
  status = nf90_inquire(ncid,ndims_in,nvars_in,ngatts_in,unlimdimid_in)
  ! Get ID of unlimited dimension

  !! print*,ndims_in, nvars_in, ngatts_in, unlimdimid_in
  do i=1,ndims_in
     ! assigning dimension name and length:
     status = nf90_inquire_dimension(ncid,i,dim_name(i), dim_len(i))
     select case(trim(dim_name(i)))
     case('xn')
        ngridx = dim_len(i)
     case('yn')
        ngridy = dim_len(i)
     case('lev')
        nlyr = dim_len(i)
     case('time')
        ntime = dim_len(i)
     case default
        print*, 'netCDF file dimension '//trim(dim_name(i))//' unknown!'
        stop
     end select
  end do
  allocate(myVarIDs(nvars_in))
  status = nf90_inq_varids(ncid,nvars=NN,varids=myVarIDs)

  ! Reading variables:
  allocate(Var4D(dim_len(1),dim_len(2),dim_len(3),dim_len(4)))
  allocate(Var3D(dim_len(1),dim_len(2),dim_len(4)))
  allocate(Var2D(dim_len(1),dim_len(2)))
  allocate(Var1D(dim_len(4)))

  do i=1,nvars_in
     status = nf90_inquire_variable(ncid, myVarIDs(i), varname, ndims = NN)
     if(status /= nf90_NoErr) print*, 'ERROR: NetCDF variable name cannot be assigned'
     status = nf90_inq_varid(ncid, varname, VarId)


     if(status /= nf90_NoErr) print*, 'ERROR: NetCDF variable ID for ',varname,' cannot be retrieved'

     Var4D = -99.
     Var3D = -99.
     Var2D = -99.
     Var1D = -99.

     ! Loading the variables from NetCDF
     select case(NN)
     case(1)
        status = nf90_get_var(ncid, VarId, Var1D)
     case(2)
        status = nf90_get_var(ncid, VarId, Var2D)
     case(3)
        status = nf90_get_var(ncid, VarId, Var3D)
     case(4)
        status = nf90_get_var(ncid, VarId, Var4D)
     case default
        print*,trim(varname),'WARNING: neither 4D nor 3D nor 2D variable!!'
        cycle
     end select
     if(status /= nf90_NoErr) print*, 'error getting variable ', trim(varname)

     ! Assigning the data to RT3/4 variable names
     select case(trim(varname))
     case('HGT')
        hgt_lev(:dim_len(1),:dim_len(2),0,:dim_len(4)) = spread(Var2D,dim=3,ncopies=ntime)
        ! for 2D variables:
     case('T2')
        temp_lev(:dim_len(1),:dim_len(2),0,:dim_len(4)) = Var3D
     case('PSFC')
        press_lev(:dim_len(1),:dim_len(2),0,:dim_len(4)) = Var3D
     case('Q2')
        relhum_lev(:dim_len(1),:dim_len(2),0,:dim_len(4)) = Var3D
        ! for 3D variables:
     case('PHB')
        ! Passing values to RT3 variables:
        hgt_lev(:dim_len(1),:dim_len(2),1:dim_len(3),:dim_len(4)) = Var4D
     case('P')
        press_lev = 0
        ! Passing values to RT3 variables:
        press_lev(:dim_len(1),:dim_len(2),1:dim_len(3),:dim_len(4)) = Var4D
     case('T')
        temp_lev = 0
        ! Passing values to RT3 variables:
        temp_lev(:dim_len(1),:dim_len(2),1:dim_len(3),:dim_len(4)) = Var4D
     case('RH')
        relhum_lev = 0
        ! Passing values to RT3 variables:
        relhum_lev(:dim_len(1),:dim_len(2),1:dim_len(3),:dim_len(4)) = Var4D
     case('QVAPOR')
        mixr_lev = 0
        ! Passing values to RT3 variables:
        mixr_lev(:dim_len(1),:dim_len(2),1:dim_len(3),:dim_len(4)) = Var4D
     case('QCLOUD')
        cloud_water_lev = 0
        ! Passing values to RT3 variables:
        cloud_water_lev(:dim_len(1),:dim_len(2),1:dim_len(3),:dim_len(4)) = Var4D
     case('QRAIN')
        rain_water_lev = 0
        ! Passing values to RT3 variables:
        rain_water_lev(:dim_len(1),:dim_len(2),1:dim_len(3),:dim_len(4)) = Var4D
     case('QICE')
        cloud_ice_lev = 0
        ! Passing values to RT3 variables:
        cloud_ice_lev(:dim_len(1),:dim_len(2),1:dim_len(3),:dim_len(4)) = Var4D
     case('QSNOW')
        snow_lev = 0
        ! Passing values to RT3 variables:
        snow_lev(:dim_len(1),:dim_len(2),1:dim_len(3),:dim_len(4)) = Var4D
     case('QGRAUP')
        graupel_lev = 0
        ! Passing values to RT3 variables:
        graupel_lev(:dim_len(1),:dim_len(2),1:dim_len(3),:dim_len(4)) = Var4D
     case('WINDDIR')
        winddir_lev = 0
        ! Passing values to RT3 variables:
        winddir_lev(:dim_len(1),:dim_len(2),1:dim_len(3),:dim_len(4)) = Var4D
     case('WINDVEL')
        windvel_lev = 0
        ! Passing values to RT3 variables:
        windvel_lev(:dim_len(1),:dim_len(2),1:dim_len(3),:dim_len(4)) = Var4D
     case('QIDX')
        ! Passing values to quality index:
        qidx(:dim_len(1),:dim_len(2),:dim_len(4)) = Var3D
     case('LAT')
        lat(:dim_len(1),:dim_len(2)) = Var2D
     case('LON')
        lon(:dim_len(1),:dim_len(2)) = Var2D
     case('year')
        year(:dim_len(1),:dim_len(2),:dim_len(4)) = Var3D
     case('month')
        month(:dim_len(1),:dim_len(2),:dim_len(4)) = Var3D
     case('day')
        day(:dim_len(1),:dim_len(2),:dim_len(4)) = Var3D
     case('hour')
        hour(:dim_len(1),:dim_len(2),:dim_len(4)) = Var3D
     case default
        print*, 'variable ',varname,' not assigned yet'
     end select
  end do

  ! ****************************
  ! Retrieving Global Attribute:
  status = nf90_get_att(ncid,NF90_GLOBAL,'grid_x',del_xy(1))
  status = nf90_get_att(ncid,NF90_GLOBAL,'grid_y',del_xy(2))
  status = nf90_get_att(ncid,NF90_GLOBAL,'origin',origin_str)
  
  ! ****************************
  ! Closing the NetCDF file
  status = nf90_close(ncid)
  
  deallocate(myVarIDs, Var4D, Var3D, Var2D, Var1D)

  return
end subroutine read_wyosonde
! ____________________________________________________________________________


! ============================================================================
! ----------------------------------------------------------------------------
! SUBROUTINE to create the RT3/4 output as NetCDF files 
!
! This subroutine only creates the NetCDF file with its corresponding
! variable names, dimentision and attributes.
! When the main code needs to write data, then the subroutine named
! 'storencdf' needs to be called in order to pass the FORTRAN variables
! to their corresponding NetCDF variables.
!
! ----------------------------------------------------------------------------
subroutine createncdf(ncflen, ncfile,NUMMU,NFREQ,NSTOKES,NLYR,XN,YN,&
     &LAYERS,freq_str,input_file,micro_phys,SELV,SLAT,SLON,origin_str)
  use netcdf
  implicit none

  integer, intent(in) :: ncflen
  character(len=ncflen), intent(in) :: ncfile
  character(len=*) input_file, micro_phys
  integer, intent(in) :: NUMMU, NFREQ,NSTOKES,NLYR, XN, YN
  real(kind=8), intent(in) :: freq_str(NFREQ), LAYERS(NLYR)
  real(kind=4), intent(in) :: SELV(XN,YN), SLAT(XN,YN), SLON(XN,YN)
  character(len=*), intent(in) :: origin_str
  
  ! internal variables
  integer :: I, status, ncid
  integer :: nDims, mu_id, stok_id, freq_id, lyr_id, time_id, xn_id, yn_id
  integer :: var_mu_id, var_stok_id, var_freq_id, var_lyr_id, var_time_id, var_elvid, var_latid, var_lonid
  integer :: var_xid, var_yid, var_tbup1_id, var_tbdn1_id, var_tbup0_id, var_tbdn0_id
  integer :: var_te2_id, var_rh2_id, var_pr2_id
  integer :: var_te_id, var_pr_id, var_rh_id, var_qv_id, var_qc_id
  integer :: var_qr_id, var_qs_id, var_qg_id, var_qi_id, var_wd_id, var_ws_id
  integer :: var_kextqc_id, var_kextqr_id, var_kextqs_id
  integer :: var_kextqg_id, var_kextqi_id, var_kextatm_id, var_kexttot_id
  integer :: var_salbtot_id, var_backsct_id, var_gcoeff_id
  integer, dimension(NSTOKES) :: stokes_var
  !real(kind=4), dimension(NTIME) :: TIMELINE
  integer :: nelv, NANGLES
  real(kind=8), dimension(10) :: elevations
  namelist/mwrobsang/nelv,elevations

  ! reading auxiliary input file with extra elevation angles
  OPEN(UNIT=100, FILE='mwrobsang',STATUS='old',IOSTAT=status)
  if(status.eq.0) then
     READ(UNIT=100,nml=mwrobsang)
     close(UNIT=100)
  else
     nelv = 0
     elevations = 0
  end if
  NANGLES = NUMMU + nelv

  status = nf90_create(trim(ncfile),NF90_CLOBBER,ncid)
  if(status /= nf90_NOERR) stop 'Output NetCDF was not possible to create: '//nf90_strerror(status)

  ! Defining dimensions
  status = nf90_def_dim(ncid, "theta_z", NANGLES, mu_id) ! NUMMU
  status = nf90_def_dim(ncid, "freq", NFREQ, freq_id)
  status = nf90_def_dim(ncid, "stokes", NSTOKES, stok_id)
  status = nf90_def_dim(ncid, "layer", NLYR, lyr_id)
  status = nf90_def_dim(ncid, "time", NF90_UNLIMITED, time_id)
  status = nf90_def_dim(ncid, "xn", XN , xn_id)
  status = nf90_def_dim(ncid, "yn", YN , yn_id)

  ! Define of variables
  status = nf90_def_var(ncid, "theta_z", NF90_REAL4, (/ mu_id /), var_mu_id)
  status = nf90_def_var(ncid, "freq", NF90_REAL4, (/ freq_id /), var_freq_id)
  status = nf90_def_var(ncid, "stokes", NF90_INT, (/ stok_id /), var_stok_id)
  status = nf90_def_var(ncid, "layer", NF90_REAL, (/lyr_id/), var_lyr_id)
  status = nf90_def_var(ncid, "time", NF90_REAL, (/ time_id /), var_time_id)
  status = nf90_def_var(ncid, "TB_UP_TOA", NF90_REAL4, (/ mu_id, freq_id, stok_id, xn_id, yn_id, time_id /), var_tbup1_id)
  status = nf90_def_var(ncid, "TB_UP_GRD", NF90_REAL4, (/ mu_id, freq_id, stok_id, xn_id, yn_id, time_id /), var_tbup0_id)
  status = nf90_def_var(ncid, "TB_DN_GRD", NF90_REAL4, (/ mu_id, freq_id, stok_id, xn_id, yn_id, time_id /), var_tbdn0_id)
  status = nf90_def_var(ncid, "TB_DN_TOA", NF90_REAL4, (/ mu_id, freq_id, stok_id, xn_id, yn_id, time_id /), var_tbdn1_id)

  !
  ! Define atmospheric state variables
  ! 1. Station level variables 
  status = nf90_def_var(ncid, "T2m", NF90_REAL4, (/xn_id, yn_id, time_id/), var_te2_id)
  status = nf90_def_var(ncid, "RH2m", NF90_REAL4, (/xn_id, yn_id, time_id/), var_rh2_id)
  status = nf90_def_var(ncid, "P2m", NF90_REAL4, (/xn_id, yn_id, time_id/), var_pr2_id)

  ! 2. Atmospheric Profile variables 
  status = nf90_def_var(ncid, "temp", NF90_REAL4, (/xn_id, yn_id, lyr_id, time_id/), var_te_id)
  status = nf90_def_var(ncid, "press", NF90_REAL4, (/xn_id, yn_id, lyr_id, time_id/), var_pr_id)
  status = nf90_def_var(ncid, "rh", NF90_REAL4, (/xn_id, yn_id, lyr_id, time_id/), var_rh_id)
  status = nf90_def_var(ncid, "qv", NF90_REAL4, (/xn_id, yn_id, lyr_id, time_id/), var_qv_id)
  status = nf90_def_var(ncid, "qc", NF90_REAL4, (/xn_id, yn_id, lyr_id, time_id/), var_qc_id)
  status = nf90_def_var(ncid, "qr", NF90_REAL4, (/xn_id, yn_id, lyr_id, time_id/), var_qr_id)
  status = nf90_def_var(ncid, "qs", NF90_REAL4, (/xn_id, yn_id, lyr_id, time_id/), var_qs_id)
  status = nf90_def_var(ncid, "qg", NF90_REAL4, (/xn_id, yn_id, lyr_id, time_id/), var_qg_id)
  status = nf90_def_var(ncid, "qi", NF90_REAL4, (/xn_id, yn_id, lyr_id, time_id/), var_qi_id)
  status = nf90_def_var(ncid, "wd", NF90_REAL4, (/xn_id, yn_id, lyr_id, time_id/), var_wd_id)
  status = nf90_def_var(ncid, "ws", NF90_REAL4, (/xn_id, yn_id, lyr_id, time_id/), var_ws_id)
  ! Definition of Micro-physics frequency dependent variables (Profiles)
  status = nf90_def_var(ncid, "kext_tot", NF90_REAL4, (/xn_id, yn_id, lyr_id, freq_id, time_id/), var_kexttot_id)
  status = nf90_def_var(ncid, "kext_atm", NF90_REAL4, (/xn_id, yn_id, lyr_id, freq_id, time_id/), var_kextatm_id)
  status = nf90_def_var(ncid, "kext_qc", NF90_REAL4, (/xn_id, yn_id, lyr_id, freq_id, time_id/), var_kextqc_id)
  status = nf90_def_var(ncid, "kext_qr", NF90_REAL4, (/xn_id, yn_id, lyr_id, freq_id, time_id/), var_kextqr_id)
  status = nf90_def_var(ncid, "kext_qs", NF90_REAL4, (/xn_id, yn_id, lyr_id, freq_id, time_id/), var_kextqs_id)
  status = nf90_def_var(ncid, "kext_qg", NF90_REAL4, (/xn_id, yn_id, lyr_id, freq_id, time_id/), var_kextqg_id)
  status = nf90_def_var(ncid, "kext_qi", NF90_REAL4, (/xn_id, yn_id, lyr_id, freq_id, time_id/), var_kextqi_id)
  status = nf90_def_var(ncid, "alb_tot", NF90_REAL4, (/xn_id, yn_id, lyr_id, freq_id, time_id/), var_salbtot_id)
  status = nf90_def_var(ncid, "back_scatt", NF90_REAL4, (/xn_id, yn_id, lyr_id, freq_id, time_id/), var_backsct_id)
  status = nf90_def_var(ncid, "g_coeff", NF90_REAL4, (/xn_id, yn_id, lyr_id, freq_id, time_id/), var_gcoeff_id)
 
  ! grid-based variables
  status = nf90_def_var(ncid, "xn", NF90_INT, (/ xn_id /), var_xid)  ! time_id
  status = nf90_def_var(ncid, "yn", NF90_INT, (/ yn_id /), var_yid)   ! time_id

  status = nf90_def_var(ncid, "elevation", NF90_REAL4, (/xn_id, yn_id/), var_elvid)
  status = nf90_def_var(ncid, "latitude", NF90_REAL4, (/xn_id, yn_id/), var_latid)
  status = nf90_def_var(ncid, "longitude", NF90_REAL4, (/xn_id, yn_id/), var_lonid)

  ! Adding Attributes
  status = nf90_put_att(ncid,var_mu_id,"short_name","theta_z")
  status = nf90_put_att(ncid,var_mu_id,"long_name","Zenithal angle")
  status = nf90_put_att(ncid,var_mu_id,"units","degree")
  status = nf90_put_att(ncid,var_mu_id,"N_obs_angles",nelv)
  status = nf90_put_att(ncid,var_mu_id,"Obs_angles_degree",elevations(:nelv))
  status = nf90_put_att(ncid,var_mu_id,"N_sim_angles",NUMMU)

  status = nf90_put_att(ncid,var_stok_id,"short_name","stk")
  status = nf90_put_att(ncid,var_stok_id,"long_name","Stokes_vector")
  status = nf90_put_att(ncid,var_stok_id,"units","1")

  status = nf90_put_att(ncid,var_lyr_id,"short_name","layer")
  status = nf90_put_att(ncid,var_lyr_id,"long_name","profile layer height")
  status = nf90_put_att(ncid,var_lyr_id,"units","km")
  status = nf90_put_att(ncid,var_lyr_id,"_FillValue", -999.9)

  status = nf90_put_att(ncid,var_freq_id,"short_name","freq")
  status = nf90_put_att(ncid,var_freq_id,"long_name","Radiometric frequency")
  status = nf90_put_att(ncid,var_freq_id,"units","GHz")

  status = nf90_put_att(ncid,var_time_id,"short_name","time")
  status = nf90_put_att(ncid,var_time_id,"long_name","days since 1970.1.1 00:00:00")
  status = nf90_put_att(ncid,var_time_id,"units","day")
  status = nf90_put_att(ncid,var_time_id,"_FillValue", -999.9)

  status = nf90_put_att(ncid,var_tbup1_id,"short_name","TB_UP_TOA")
  status = nf90_put_att(ncid,var_tbup1_id,"long_name","TOA Brightness Temperature (Upwelling)")
  status = nf90_put_att(ncid,var_tbup1_id,"units","K")
  status = nf90_put_att(ncid,var_tbup1_id,"_FillValue", -999.9)

  status = nf90_put_att(ncid,var_tbdn1_id,"short_name","TB_DN_TOA")
  status = nf90_put_att(ncid,var_tbdn1_id,"long_name","TOA Brightness Temperature (Downwelling)")
  status = nf90_put_att(ncid,var_tbdn1_id,"units","K")
  status = nf90_put_att(ncid,var_tbdn1_id,"_FillValue", -999.9)

  status = nf90_put_att(ncid,var_tbup0_id,"short_name","TB_UP_GND")
  status = nf90_put_att(ncid,var_tbup0_id,"long_name","GROUND Brightness Temperature (Upwelling)")
  status = nf90_put_att(ncid,var_tbup0_id,"units","K")
  status = nf90_put_att(ncid,var_tbup0_id,"_FillValue", -999.9)

  status = nf90_put_att(ncid,var_tbdn0_id,"short_name","TB_DN_GND")
  status = nf90_put_att(ncid,var_tbdn0_id,"long_name","GROUND Brightness Temperature (Downwelling)")
  status = nf90_put_att(ncid,var_tbdn0_id,"units","K")
  status = nf90_put_att(ncid,var_tbdn0_id,"_FillValue", -999.9)

  ! Attributes for Station level variables
  status = nf90_put_att(ncid,var_te2_id,"short_name","T2m")
  status = nf90_put_att(ncid,var_te2_id,"long_name","2m Temperature")
  status = nf90_put_att(ncid,var_te2_id,"units","K")
  status = nf90_put_att(ncid,var_te2_id,"_FillValue",-999.9)

  status = nf90_put_att(ncid,var_rh2_id,"short_name","RH_s")
  status = nf90_put_att(ncid,var_rh2_id,"long_name","2m Relative humidity")
  status = nf90_put_att(ncid,var_rh2_id,"units","%")
  status = nf90_put_att(ncid,var_rh2_id,"_FillValue",-999.9)

  status = nf90_put_att(ncid,var_pr2_id,"short_name","P_s")
  status = nf90_put_att(ncid,var_pr2_id,"long_name","2m air pressure")
  status = nf90_put_att(ncid,var_pr2_id,"units","hPa")
  status = nf90_put_att(ncid,var_pr2_id,"_FillValue",-999.9)
  
  ! Attributes for Profile variables
  status = nf90_put_att(ncid,var_te_id,"short_name","temp")
  status = nf90_put_att(ncid,var_te_id,"long_name","temperature")
  status = nf90_put_att(ncid,var_te_id,"units","K")
  status = nf90_put_att(ncid,var_te_id,"_FillValue",-999.9)

  status = nf90_put_att(ncid,var_pr_id,"short_name","press")
  status = nf90_put_att(ncid,var_pr_id,"long_name","pressure")
  status = nf90_put_att(ncid,var_pr_id,"units","hPa")
  status = nf90_put_att(ncid,var_pr_id,"_FillValue",-999.9)

  status = nf90_put_att(ncid,var_rh_id,"short_name","rh")
  status = nf90_put_att(ncid,var_rh_id,"long_name","relative humidity")
  status = nf90_put_att(ncid,var_rh_id,"units","%")
  status = nf90_put_att(ncid,var_rh_id,"_FillValue",-999.9)
  
  status = nf90_put_att(ncid,var_qv_id,"short_name","qv")
  status = nf90_put_att(ncid,var_qv_id,"long_name","specific humidity")
  status = nf90_put_att(ncid,var_qv_id,"units","g m-3")
  status = nf90_put_att(ncid,var_qv_id,"_FillValue",-999.9)

  status = nf90_put_att(ncid,var_qc_id,"short_name","qc")
  status = nf90_put_att(ncid,var_qc_id,"long_name","cloud water content")
  status = nf90_put_att(ncid,var_qc_id,"units","g m-3")
  status = nf90_put_att(ncid,var_qc_id,"_FillValue",-999.9)

  status = nf90_put_att(ncid,var_qr_id,"short_name","qr")
  status = nf90_put_att(ncid,var_qr_id,"long_name","rain water content")
  status = nf90_put_att(ncid,var_qr_id,"units","g m-3")
  status = nf90_put_att(ncid,var_qr_id,"_FillValue",-999.9)
  
  status = nf90_put_att(ncid,var_qs_id,"short_name","qs")
  status = nf90_put_att(ncid,var_qs_id,"long_name","snow water content")
  status = nf90_put_att(ncid,var_qs_id,"units","g m-3")
  status = nf90_put_att(ncid,var_qs_id,"_FillValue",-999.9)

  status = nf90_put_att(ncid,var_qg_id,"short_name","qg")
  status = nf90_put_att(ncid,var_qg_id,"long_name","graupel water content")
  status = nf90_put_att(ncid,var_qg_id,"units","g m-3")
  status = nf90_put_att(ncid,var_qg_id,"_FillValue",-999.9)

  status = nf90_put_att(ncid,var_qi_id,"short_name","qi")
  status = nf90_put_att(ncid,var_qi_id,"long_name","ice water content")
  status = nf90_put_att(ncid,var_qi_id,"units","g m-3")
  status = nf90_put_att(ncid,var_qi_id,"_FillValue",-999.9)

  status = nf90_put_att(ncid,var_wd_id,"short_name","wd")
  status = nf90_put_att(ncid,var_wd_id,"long_name","wind direction")
  status = nf90_put_att(ncid,var_wd_id,"units","deg")
  status = nf90_put_att(ncid,var_wd_id,"_FillValue",-999.9)

  status = nf90_put_att(ncid,var_ws_id,"short_name","ws")
  status = nf90_put_att(ncid,var_ws_id,"long_name","wind speed")
  status = nf90_put_att(ncid,var_ws_id,"units","knot")
  status = nf90_put_att(ncid,var_ws_id,"_FillValue",-999.9)


  status = nf90_put_att(ncid,var_kexttot_id,"short_name","kext_tot")
  status = nf90_put_att(ncid,var_kexttot_id,"long_name","total extinction coefficient")
  status = nf90_put_att(ncid,var_kexttot_id,"units","km-1")
  status = nf90_put_att(ncid,var_kexttot_id,"_FillValue",-999.9)
  
  status = nf90_put_att(ncid,var_kextatm_id,"short_name","kext_atm")
  status = nf90_put_att(ncid,var_kextatm_id,"long_name","atmospheric extinction coefficient")
  status = nf90_put_att(ncid,var_kextatm_id,"units","km-1")
  status = nf90_put_att(ncid,var_kextatm_id,"_FillValue",-999.9)

  status = nf90_put_att(ncid,var_kextqc_id,"short_name","kext_cloud")
  status = nf90_put_att(ncid,var_kextqc_id,"long_name","cloud extinction coefficient")
  status = nf90_put_att(ncid,var_kextqc_id,"units","km-1")
  status = nf90_put_att(ncid,var_kextqc_id,"_FillValue",-999.9)

  status = nf90_put_att(ncid,var_kextqr_id,"short_name","kext_rain")
  status = nf90_put_att(ncid,var_kextqr_id,"long_name","rain extinction coefficient")
  status = nf90_put_att(ncid,var_kextqr_id,"units","km-1")
  status = nf90_put_att(ncid,var_kextqr_id,"_FillValue",-999.9)
  
  status = nf90_put_att(ncid,var_kextqs_id,"short_name","kext_snow")
  status = nf90_put_att(ncid,var_kextqs_id,"long_name","snow extinction coefficient")
  status = nf90_put_att(ncid,var_kextqs_id,"units","km-1")
  status = nf90_put_att(ncid,var_kextqs_id,"_FillValue",-999.9)

  status = nf90_put_att(ncid,var_kextqg_id,"short_name","kext_graupel")
  status = nf90_put_att(ncid,var_kextqg_id,"long_name","graupel extinction coefficient")
  status = nf90_put_att(ncid,var_kextqg_id,"units","km-1")
  status = nf90_put_att(ncid,var_kextqg_id,"_FillValue",-999.9)

  status = nf90_put_att(ncid,var_kextqi_id,"short_name","kext_ice")
  status = nf90_put_att(ncid,var_kextqi_id,"long_name","ice extinction coefficient")
  status = nf90_put_att(ncid,var_kextqi_id,"units","km-1")
  status = nf90_put_att(ncid,var_kextqi_id,"_FillValue",-999.9)
  
  status = nf90_put_att(ncid,var_salbtot_id,"short_name","alb_tot")
  status = nf90_put_att(ncid,var_salbtot_id,"long_name","total surface albedo")
  status = nf90_put_att(ncid,var_salbtot_id,"units","")
  status = nf90_put_att(ncid,var_salbtot_id,"_FillValue",-999.9)

  status = nf90_put_att(ncid,var_backsct_id,"short_name","backscatt")
  status = nf90_put_att(ncid,var_backsct_id,"long_name","backscattering coefficient")
  status = nf90_put_att(ncid,var_backsct_id,"units","km-1")
  status = nf90_put_att(ncid,var_backsct_id,"_FillValue",-999.9)

  status = nf90_put_att(ncid,var_gcoeff_id,"short_name","g_coeff")
  status = nf90_put_att(ncid,var_gcoeff_id,"long_name","asymetry factor")
  status = nf90_put_att(ncid,var_gcoeff_id,"units","1")
  status = nf90_put_att(ncid,var_gcoeff_id,"_FillValue",-999.9)


  ! ***** Grid variables 
  status = nf90_put_att(ncid,var_xid,"short_name","Xn")
  status = nf90_put_att(ncid,var_xid,"long_name","X_grid")
  status = nf90_put_att(ncid,var_yid,"short_name","Yn")
  status = nf90_put_att(ncid,var_yid,"long_name","Y_grid")

  status = nf90_put_att(ncid,var_elvid,"short_name","ELV")
  status = nf90_put_att(ncid,var_elvid,"long_name","Elevation")
  status = nf90_put_att(ncid,var_elvid,"units","km")

  status = nf90_put_att(ncid,var_latid,"short_name","LAT")
  status = nf90_put_att(ncid,var_latid,"long_name","Latitude")
  status = nf90_put_att(ncid,var_latid,"units","DEG")
  
  status = nf90_put_att(ncid,var_lonid,"short_name","LON")
  status = nf90_put_att(ncid,var_lonid,"long_name","Longitude")
  status = nf90_put_att(ncid,var_lonid,"units","DEG")

  status = nf90_put_att(ncid,NF90_GLOBAL,"Input_data", input_file)
  status = nf90_put_att(ncid,NF90_GLOBAL,"Wyosonde_station", trim(origin_str))
  status = nf90_put_att(ncid,NF90_GLOBAL,"Hydrometeor_Microphysics", micro_phys)
  status = nf90_put_att(ncid,NF90_GLOBAL,"Contact","Pablo.Saavedra@uib.no")
  status = nf90_put_att(ncid,NF90_GLOBAL,"Institution","Geophysical Institute, University of Bergen")

  ! End definitions
  status = nf90_enddef(ncid)
  
  ! Putting variables independent of time:
  stokes_var = (/(I,I=1,NSTOKES)/)
  !TIMELINE = -999.9
  status = nf90_put_var(ncid, var_lyr_id, LAYERS)
  status = nf90_put_var(ncid, var_freq_id, freq_str)
  status = nf90_put_var(ncid, var_stok_id, stokes_var)
  !status = nf90_put_var(ncid, var_time_id, TIMELINE)
  status = nf90_put_var(ncid, var_elvid, SELV)
  status = nf90_put_var(ncid, var_latid, SLAT)
  status = nf90_put_var(ncid, var_lonid, SLON)
  
  status = nf90_close(ncid)
  if (status /= NF90_NOERR) stop 'Error closing after creation NetCDF file!'
end subroutine createncdf
! ___________________________________________________________________________


! ____________________________________________________________________________
! ----------------------------------------------------------------------------
! SUBROUTINE to store the RT3/4 data in the created NetCDF output file
!
! ----------------------------------------------------------------------------
subroutine storencdf(OUT_FILE,MU_VALUES,NUMMU,HEIGHT,NOUTLEVELS,OUTVAR,NSTOKES,time_len)
  use netcdf
  use, intrinsic :: iso_c_binding
  
  implicit none

  ! Interface to the C code for Unix time retrieval:
  interface
     function F2UnixTime(datum) result(val) bind(c, name='F2UnixTime')
       use, intrinsic :: iso_c_binding
       integer(kind=c_int) :: datum(6)
       real(kind=c_double) :: val
     end function F2UnixTime
  end interface
  
  character(len=*), intent(in) :: OUT_FILE
  real(kind=8), intent(in) :: MU_VALUES(NUMMU), HEIGHT(NOUTLEVELS), OUTVAR(NUMMU,NSTOKES,2,NOUTLEVELS)
  integer, intent(in) :: NUMMU, NOUTLEVELS, NSTOKES, time_len

  ! internal variables
  integer :: i, j, k
  integer :: status, ncid, VarId, idx, idf
  integer :: nDims, unlimdimid, freq_id
  character(len=len(OUT_FILE)+3) :: ncfile
  character(len=40) :: dim_name
  integer :: x_grid, y_grid, i_freq, freq_len, NTIME
  real(kind=8) :: AllFreq(30)
  real(kind=8), allocatable, dimension(:) :: ZENITH_THTA  ! (NUMMU)
  real(kind=8), allocatable, dimension(:,:,:,:) :: TB_THTA
  real(kind=8), allocatable, dimension(:) :: elevations, elvmu
  real(kind=c_double) :: TIMELINE
  integer(kind=c_int) :: date(6)
  real(kind=8), parameter :: PI = 4.0*atan(1.0)
  integer :: nelv, NANG
  
  namelist/mwrobsang/nelv,elevations
  

  ! Extracting information from the OUT_FILE character string:
  ! * The OUT_FILE has the form like:
  ! ../output/TB/RT3TB13090112Exp7.6MaxGa0.2Exp4.0MaxGaExp8.0x001y001f27.20
  !
  ! which needs to be transformed to a NetCDF file like:
  ! ../output/TB/RT3TB_Exp7.6MaxGa0.2Exp4.0MaxGaExp8.0_f27.2.nc

  ! * grid indices:
  idx = scan(OUT_FILE,'x',back=.true.)+1
  if(idx.eq.1) stop 'no x000_ found in string passed'

  read(OUT_FILE(idx:),'(I03XI03)') x_grid, y_grid

  ! * Date and * getting microphysics from OUT_FILE:
  date = 0
  idx = scan(OUT_FILE,'=',back=.true.)+1
  if(idx.eq.1) stop 'no separator = found in string passed'
  idf = scan(OUT_FILE,'x',back=.true.)
  read(OUT_FILE(idx:idf-1),'(4I02)') date(1:4) !, micro_phys  ! '(5X4I02A)'
  date(1) = date(1)+2000
  TIMELINE = F2UnixTime(date)

  ! constructing netCDF file to write data:
  idf = scan(OUT_FILE,'=',back=.true.)-1
  ncfile = OUT_FILE(:idf)

  status = NF90_OPEN(ncfile,MODE=NF90_WRITE,NCID=ncid)
  if(status/=NF90_NOERR) stop 'Opening the NetCDF to add in STORENCDF()'

  ! Getting NetCDF file dimensions and lengths:
  ! For time:
  !!!status = nf90_inquire(ncid, nDimensions = nDims,unlimitedDimID = unlimdimid)
  status = nf90_inq_varid(ncid,"time",unlimdimid)
  status = nf90_inquire_dimension(ncid,unlimdimid,dim_name, NTIME)
  !!!allocate(TIMELINE(time_len))
  !!!status = nf90_get_var(ncid,unlimdimid,TIMELINE)
  !!!time_len = minloc(TIMELINE,MASK=TIMELINE.LT.0)

  ! For frequency
  ! * Frequency from OUT_FILE:
  idx = scan(OUT_FILE,'f',back=.true.)+1
  read(OUT_FILE(idx:),'(I6)') i_freq

  AllFreq = -999.
  status = nf90_inq_varid(ncid,"freq",freq_id)
  status = nf90_inquire_dimension(ncid,freq_id,dim_name,freq_len)
  status = nf90_get_var(ncid,freq_id,AllFreq(1:freq_len))

  if(i_freq.LT.1) stop 'ERROR finding frequency index in STORENCDF'
  print*, 'Date, UXTIME, x-grid, y-grid, freq dim has: ',date, TIMELINE, x_grid, y_grid, AllFreq(i_freq)
  
  ! Writting variable values ZENITH_THTA into NetCDF file:
  status = nf90_inq_varid(ncid, "theta_z", VarId)
  if(status /= nf90_NoErr)  stop 'cos(MU) ID cannot be assigned!'
  status = nf90_inquire_dimension(ncid,VarId,dim_name,NANG)
  status = nf90_get_att(ncid,VarID,"N_obs_angles",nelv)

  allocate(ZENITH_THTA(NANG))
  allocate(TB_THTA(NANG,NSTOKES,2,NOUTLEVELS))
  allocate(elevations(nelv))
  allocate(elvmu(nelv))

  status = nf90_get_att(ncid,VarId,"Obs_angles_degree",elevations)
  
  ! converting input MWR elevation angles into zenithal angles cos(pi/2-mu)
  elvmu = cos((90.0-elevations)*PI/180.)

  ! Checking whether additional observation angles are needed:
  if(nelv.GT.0) then
     ! Interpolate the values for the additional angles:
     CALL interp1_1D(MU_VALUES, OUTVAR, NUMMU, elvmu, nelv,&
          & ZENITH_THTA, NANG, TB_THTA, NSTOKES,2,NOUTLEVELS)
  else
     ! No additional angles, only simulations:
     ZENITH_THTA(:NANG) = MU_VALUES(:NUMMU)
  end if
  
  if(time_len.EQ.1.AND.i_freq.EQ.1) then
     ! converting cos(mu) to zenithal angle:
     ZENITH_THTA = acos(ZENITH_THTA)*180.0/PI
     status = nf90_put_var(ncid,VarId,ZENITH_THTA(:NANG))
     if(status /= nf90_NoErr) stop 'cos(MU) values cannot be stored!'


     ! writting Initial date as global variable:
     status = nf90_redef(ncid)
     status = nf90_put_att(ncid,NF90_GLOBAL,"Start_Date", date) !OUT_FILE(19:26))
     status = nf90_enddef(ncid)

  end if
  
  if(time_len.EQ.NTIME.AND.i_freq.EQ.freq_len) then
     ! writting Initial date as global variable:
     status = nf90_redef(ncid)
     status = nf90_put_att(ncid,NF90_GLOBAL,"End_Date", date) !OUT_FILE(19:26))  ! (16:23)
     status = nf90_enddef(ncid)
  end if
  
  ! writing time
  ! writting TB_UPwelling
  status = nf90_inq_varid(ncid, "time", VarId)
  if(status /= nf90_NoErr) stop 'Time cannot be assigned!'
  status = nf90_put_var(ncid,VarId,TIMELINE,start=(/time_len/))  ! date(3)
  if(status /= nf90_NoErr) stop 'Time values cannot be stored!'

  ! writting TOA TB_UPwelling ( OUTVAR has the dimension of [mu,stokes,Xwelling,level]) 
  status = nf90_inq_varid(ncid, "TB_UP_TOA", VarId)
  if(status /= nf90_NoErr) stop 'TB_UP TOA cannot be assigned!' ! OUTVAR(:,:,1,1)
  status = nf90_put_var(ncid,VarId,TB_THTA(:NANG,:,1,1),start=(/1,i_freq,1,x_grid,y_grid,time_len/),count=(/NANG,1,2,1,1,1/))
  !status = nf90_put_var(ncid,VarId,OUTVAR(:,:,1,:),start=(/1,1,1,x_grid,y_grid,time_len/),count=(/NUMMU,2,NOUTLEVELS,1,1,1/))
  if(status /= nf90_NoErr) stop 'TB_UP TOA values cannot be stored!'
  
  ! writting TOA TB_DOWNwelling
  status = nf90_inq_varid(ncid, "TB_DN_TOA", VarId)
  if(status /= nf90_NoErr) stop 'TB_DN TOA cannot be assigned!' ! OUTVAR(:,:,2,1)
  !status = nf90_put_var(ncid,VarId,OUTVAR(:,:,2,:),start=(/1,1,1,time_len/),count=(/NUMMU,2,NOUTLEVELS,1/))
  status = nf90_put_var(ncid,VarId,TB_THTA(:NANG,:,2,1),start=(/1,i_freq,1,x_grid,y_grid,time_len/),count=(/NANG,1,2,1,1,1/))
  if(status /= nf90_NoErr) stop 'TB_DN TOA values cannot be stored!'
  
  ! writting GROUND TB_UPwelling ( OUTVAR has the dimension of [mu,stokes,Xwelling,level]) 
  status = nf90_inq_varid(ncid, "TB_UP_GRD", VarId)
  if(status /= nf90_NoErr) stop 'TB_UP GRD cannot be assigned!'
  status = nf90_put_var(ncid,VarId,TB_THTA(:NANG,:,1,2),start=(/1,i_freq,1,x_grid,y_grid,time_len/),count=(/NANG,1,2,1,1,1/))
  !status = nf90_put_var(ncid,VarId,OUTVAR(:,:,1,:),start=(/1,1,1,x_grid,y_grid,time_len/),count=(/NUMMU,2,NOUTLEVELS,1,1,1/))
  if(status /= nf90_NoErr) stop 'TB_UP GRD values cannot be stored!'
  
  ! writting GROUND TB_DOWNwelling
  status = nf90_inq_varid(ncid, "TB_DN_GRD", VarId)
  if(status /= nf90_NoErr) stop 'TB_DN GRD cannot be assigned!'
  !status = nf90_put_var(ncid,VarId,OUTVAR(:,:,2,:),start=(/1,1,1,time_len/),count=(/NUMMU,2,NOUTLEVELS,1/))
  status = nf90_put_var(ncid,VarId,TB_THTA(:NANG,:,2,2),start=(/1,i_freq,1,x_grid,y_grid,time_len/),count=(/NANG,1,2,1,1,1/))
  if(status /= nf90_NoErr) stop 'TB_DN GRD values cannot be stored!'
    
  ! writting x_grid and y grid indexes:
  status = nf90_inq_varid(ncid,"xn", VarId)
  status = nf90_put_var(ncid, VarId, x_grid, start = (/x_grid/))
  status = nf90_inq_varid(ncid,"yn", VarId)
  status = nf90_put_var(ncid, VarId, y_grid, start = (/y_grid/))
  
  status = NF90_CLOSE(ncid)
  if (status /= NF90_NOERR) stop 'Closing NetCDF was not possible!'

  if(allocated(ZENITH_THTA)) deallocate(ZENITH_THTA)
  if(allocated(TB_THTA)) deallocate(TB_THTA)
  if(allocated(elevations)) deallocate(elevations)
  if(allocated(elvmu)) deallocate(elvmu)

  return
  
end subroutine storencdf
!  if(status /= NF90_NoErr) stop 'Creating the NetCDF to write!'


! ____________________________________________________________________________
! ----------------------------------------------------------------------------
! SUBROUTINE Microphysics variable storege for the RT3/4 NetCDF output file
!
! ----------------------------------------------------------------------------
subroutine MP_storencdf(OUT_FILE,time_len,i_freq,y_grid,x_grid,NLYR,LAYERS,TEMP,PRESS,RH,QV,QC,&
     &WD, WS, KEXTQC, KEXTATM, KEXTTOT, ALBEDO, BACKSCATT, GCOEFF)
  use netcdf

  implicit none

  character(len=*), intent(in) :: OUT_FILE
  integer, intent(in) :: time_len, i_freq, y_grid, x_grid, NLYR
  real(kind=8), intent(in) :: TEMP(0:NLYR), PRESS(0:NLYR), RH(0:NLYR)  ! 0: because surface values
  real(kind=8), intent(in) :: LAYERS(NLYR), QV(NLYR), QC(NLYR), WD(NLYR), WS(NLYR)
  real(kind=8), intent(in) :: KEXTTOT(NLYR), KEXTATM(NLYR), KEXTQC(NLYR)
  real(kind=8), intent(in) :: ALBEDO(NLYR), BACKSCATT(NLYR), GCOEFF(NLYR)

  ! internal variables
  integer :: status, ncid, VarId
  integer :: nDims, unlimdimid, freq_id
  character(len=len(OUT_FILE)+3) :: ncfile
  character(len=30) :: dim_name
  real(kind=8) :: AllFreq(30), freq
  integer :: freq_len

  ncfile = OUT_FILE
  status = NF90_OPEN(ncfile, MODE=NF90_WRITE, NCID=ncid)
  if(status/=NF90_NOERR) stop 'Opening the NetCDF to add'

  ! Getting NetCDF file dimensions and lengths:

  ! For frequency:
  AllFreq = -99.
  status = nf90_inq_varid(ncid,"freq",freq_id)
  status = nf90_inquire_dimension(ncid,freq_id,dim_name,freq_len)
  status = nf90_get_var(ncid,freq_id,AllFreq(1:freq_len))

  if(i_freq.LT.1) stop 'ERROR: finding the frequency index in NP_STORENCDF'

  ! ********** Writting Station level Variables ****************************
  ! Writting the 2m Temperature
  status = nf90_inq_varid(ncid, "T2m", VarId)
  if(status /= nf90_NoErr) stop 'T2m variable ID cannot be read!'
  status = nf90_put_var(ncid,VarId, TEMP(0:0), start=(/x_grid , y_grid, time_len/), count=(/1,1,1/))
  if(status /= nf90_NoErr) stop 'T2m variable cannot be written!'

  ! Writting the 2m RH
  status = nf90_inq_varid(ncid, "RH2m", VarId)
  if(status /= nf90_NoErr) stop 'RH2m variable ID cannot be read!'
  status = nf90_put_var(ncid, VarId, RH(0:0),  start=(/x_grid, y_grid, time_len/), count=(/1,1,1/))
  
  ! Writting the 2m Air Pressure
  status = nf90_inq_varid(ncid, "P2m", VarId)
  if(status /= nf90_NoErr) stop 'Air pressure variable ID cannot be read!'
  status = nf90_put_var(ncid, VarId, PRESS(0:0),  start=(/x_grid, y_grid, time_len/), count=(/1,1,1/))
  
  ! ********** Writting Profile Variables ****************************
  ! Writting the Temperature
  status = nf90_inq_varid(ncid, "temp", VarId)
  if(status /= nf90_NoErr) stop 'Temperature profile ID cannot be read!'
  status = nf90_put_var(ncid, VarId, TEMP, start=(/x_grid, y_grid, 1, time_len/),count=(/1,1,NLYR,1/))
  if(status /= nf90_NoErr) stop 'Temperature profile cannot be written!'

  ! Writting the Pressure
  status = nf90_inq_varid(ncid, "press", VarId)
  if(status /= nf90_NoErr) stop 'Pressure profile ID cannot be read!'
  status = nf90_put_var(ncid, VarId, PRESS, start=(/x_grid, y_grid, 1, time_len/),count=(/1,1,NLYR,1/))
  if(status /= nf90_NoErr) stop 'Pressure profile cannot be written!'

  ! Writting the Relative Humidity
  status = nf90_inq_varid(ncid, "rh", VarId)
  if(status /= nf90_NoErr) stop 'RH profile ID cannot be read!'
  status = nf90_put_var(ncid, VarId, RH, start=(/x_grid, y_grid ,1, time_len/),count=(/1,1,NLYR,1/))
  if(status /= nf90_NoErr) stop 'RH profile cannot be written!'

  ! Writting the QV variable
  status = nf90_inq_varid(ncid, "qv", VarId)
  if(status /= nf90_NoErr) stop 'QV variable ID cannot be read!'
  status = nf90_put_var(ncid, VarId, QV, start=(/x_grid, y_grid, 1, time_len/),count=(/1,1,NLYR,1/))
  if(status /= nf90_NoErr) stop 'QV cannot be written!'
  ! Writting the QC variable
  status = nf90_inq_varid(ncid, "qc", VarId)
  if(status /= nf90_NoErr) stop 'QC variable ID cannot be read!'
  status = nf90_put_var(ncid, VarId, QC, start=(/x_grid, y_grid, 1, time_len/),count=(/1,1,NLYR,1/))
  if(status /= nf90_NoErr) stop 'QC cannot be written!'
  ! Writting the Wind Direction variable
  status = nf90_inq_varid(ncid, "wd", VarId)
  if(status /= nf90_NoErr) stop 'WD variable ID cannot be read!'
  status = nf90_put_var(ncid, VarId, WD, start=(/x_grid, y_grid, 1, time_len/),count=(/1,1,NLYR,1/))
  if(status /= nf90_NoErr) stop 'WD cannot be written!'
  ! Writting the Wind Speed variable
  status = nf90_inq_varid(ncid, "ws", VarId)
  if(status /= nf90_NoErr) stop 'WS variable ID cannot be read!'
  status = nf90_put_var(ncid, VarId, WS, start=(/x_grid, y_grid, 1, time_len/),count=(/1,1,NLYR,1/))
  if(status /= nf90_NoErr) stop 'WS cannot be written!'

  ! ---------------------------------------
  ! Writting the ATMOSPHERIC Extintion coeff
  status = nf90_inq_varid(ncid, "kext_atm", VarId)
  if(status /= nf90_NoErr) stop 'KEXT_ATMOS variable ID cannot be read!'
  status = nf90_put_var(ncid, VarId, KEXTATM, start=(/x_grid, y_grid, 1, i_freq, time_len/),count=(/1,1,NLYR,1,1/))
  if(status /= nf90_NoErr) stop 'KEXT_ATMOS cannot be written!'
! Writting the Cloud Extintion coeff
  status = nf90_inq_varid(ncid, "kext_qc", VarId)
  if(status /= nf90_NoErr) stop 'KEXT_CLOUD variable ID cannot be read!'
  status = nf90_put_var(ncid, VarId, KEXTQC, start=(/x_grid, y_grid, 1, i_freq, time_len/),count=(/1,1,NLYR,1,1/))
  if(status /= nf90_NoErr) stop 'KEXT_CLOUD cannot be written!'
! Writting the Total Extintion coeff
  status = nf90_inq_varid(ncid, "kext_tot", VarId)
  if(status /= nf90_NoErr) stop 'KEXT_TOTAL variable ID cannot be read!'
  status = nf90_put_var(ncid, VarId, KEXTTOT, start=(/x_grid, y_grid, 1, i_freq, time_len/),count=(/1,1,NLYR,1,1/))
  if(status /= nf90_NoErr) stop 'KEXT_TOT cannot be written!'

  ! Writting the Total Albedo coeff
  status = nf90_inq_varid(ncid, "alb_tot", VarId)
  if(status /= nf90_NoErr) stop 'TOTAL Albedo variable ID cannot be read!'
  status = nf90_put_var(ncid, VarId, ALBEDO, start=(/x_grid, y_grid, 1, i_freq, time_len/),count=(/1,1,NLYR,1,1/))
  if(status /= nf90_NoErr) stop 'TOTAL  ALBEDO cannot be written!'

  ! Writting the Backscattering coeff
  status = nf90_inq_varid(ncid, "back_scatt", VarId)
  if(status /= nf90_NoErr) stop 'Backscattering variable ID cannot be read!'
  status = nf90_put_var(ncid, VarId, BACKSCATT, start=(/x_grid, y_grid, 1, i_freq, time_len/),count=(/1,1,NLYR,1,1/))
  if(status /= nf90_NoErr) stop 'Backscattering cannot be written!'

  ! Writting the asymetry factor
  status = nf90_inq_varid(ncid, "g_coeff", VarId)
  if(status /= nf90_NoErr) stop 'G-factor variable ID cannot be read!'
  status = nf90_put_var(ncid, VarId, GCOEFF, start=(/x_grid, y_grid, 1, i_freq, time_len/),count=(/1,1,NLYR,1,1/))
  if(status /= nf90_NoErr) stop 'G-factor cannot be written!'
  
  status = NF90_CLOSE(ncid)
  if (status /= NF90_NOERR) stop 'Closing NetCDF was not possible!'
  return
end subroutine MP_storencdf
! _____________________________________________________________________________________


! -------------------------------------------------------------------------------------
! Subroutine to interpolate extra observations angles
! in case the input value is out of limits, extrapolation is attended with the two first
! (lower extrapolation) or last (upper extrapolation) values of the vector.
!
subroutine interp1_1D(Xin, Yin, Nin, X0, N0, Xout, Nout, Yout, Nstk, Nflx, Nlev)
  
  ! Interpolated abssice values must increase monotonically, 
  ! the ordenate values can be decreasing or increasing
  ! Repeated values in Xin and X0 are omitted
  
  implicit none
  integer, intent(in) :: Nin, N0, Nstk, Nflx, Nlev, Nout
  real(kind=8), intent(in) :: Xin(Nin), X0(N0), Yin(Nin,Nstk,Nflx,Nlev)
  real(kind=8), intent(out):: Xout(Nout)
  real(kind=8), intent(out):: Yout(Nout,Nstk,Nflx,Nlev)
  integer :: h, idx, idn, iout
  real(kind=8) :: a, b, Fa(Nstk, Nflx, Nlev), Fb(Nstk, Nflx, Nlev), F0(Nstk, Nflx, Nlev)
  real(kind=8) :: eps = 1.0E-4
  
  ! union of Xin and X0 sets
  Yout = -69.8
  Yout(1:Nin,:,:,:) = Yin
  
  Xout = -69.0
  Xout(1:Nin) = Xin
    
  do h = 1, N0
     !if(any(abs(Xout-X0(h)).LT.eps)) cycle
     !iout = iout + 1
     if(X0(h).GT.maxval(Xout)) then
        idx = maxloc(Xout,1)+1
        a = Xout(idx-2)
        b = Xout(idx-1)
        Fa = Yout(idx-2,:,:,:)
        Fb = Yout(idx-1,:,:,:)
     else if(X0(h).LT.minval(Xout)) then
        idx = 1
        a = Xout(idx)
        b = Xout(idx+1)
        Fa = Yout(idx,:,:,:)
        Fb = Yout(idx+1,:,:,:)
     else
        idx = minloc(Xout,DIM=1,MASK=X0(h)<=Xout)
        a = Xout(idx-1)
        b = Xout(idx)
        Fa = Yout(idx-1,:,:,:)
        Fb = Yout(idx,:,:,:)
     end if
     
     if(abs(X0(h)-b).LT.eps) then
        F0 = Fb
     else if(abs(X0(h)-a).LT.eps) then
        F0 = Fa
     else
        F0 = Fa + (X0(h)-a)*(Fb-Fa)/(b-a)
     end if
     idn = Nin+h-1
     Xout(idx+1:idn+1) = Xout(idx:idn)
     Xout(idx) = X0(h)

     Yout(idx+1:idn+1, :, :, :) = Yout(idx:idn,:,:,:)
     Yout(idx, :, :, :)   = F0
     
  end do
  
end subroutine interp1_1D

! ---------------------------------------------------------------
! HUMIDITY CONVERSION FORMULAS
! Calculation formulas for humidity (B210973EN-F)
! By (c) VAISALA 2003
! https://www.hatchability.com/Vaisala.pdf
subroutine mixr2rh(nx, ny, nz, nt, MIXR, P, T, RH)
  implicit none
  integer, intent(in) :: nx, ny, nz, nt
  real(kind=8), intent(in), dimension(nx,ny,nz,nt) :: MIXR, P, T
  real(kind=8), intent(out), dimension(nx,ny,nz,nt) :: RH

  integer :: i, j
  real, dimension(nx,ny,nz,nt) :: PWS, etha, A
  real, parameter :: COEFF = 2.16679 ! [g K J^-1]
  real, parameter :: Tc = 647.096  ! critical temperature [K]
  real, parameter :: Pc = 220640   ! critical pressure [hPa]
  real, parameter :: B  = 0.6219907 ! constant for air [kg/kg]
  real, parameter :: CC(6) = (/ -7.85951783, 1.84408259, &
       & -11.7866497, 22.6807411, -15.9618719, 1.80122502 /)
  real, parameter :: EE(6) = (/1.0, 1.5, 3.0, 3.5, 4.0, 7.5/)
  etha = 1.0d0 - T/Tc
  A = 0.0d0
  do i=1, 6
     A = A + CC(i)*(etha**EE(i))
  end do
  PWS = Pc*exp(A*Tc/T)
  !RH = 1E-3*MIXR*T/PWS/COEFF
  !RH = 100*PW/PWS
  RH = 100*MIXR*P/(MIXR + B)/PWS
end subroutine mixr2rh

! -----------------------------------------------------------------
! CONVERT perturbation potential temperature (theta-t0)
! to Temperature.
!
! Based on "[Wrf-users] perturbation potential temperature"
! https://mailman.ucar.edu/pipermail/wrf-users/2010/001896.html
! Where thete: Potential Temperature and T0=300K
! kappa: the Poisson constant (kappa = R/c_p), the ratio of the gas
! constant R to the specific heat at constant pressure c_p.

subroutine PERTHETA2T(nx, ny, nz, nt, Tper, P, T)
  implicit none
  integer, intent(in) :: nx, ny, nz, nt
  real(kind=8), intent(in), dimension(nx,ny,nz,nt) :: Tper, P
  real(kind=8), intent(inout), dimension(nx,ny,nz,nt) :: T

  real(kind=8), dimension(nx,ny,nz,nt) :: theta
  real, parameter :: T0 = 300 ! [K]
  real, parameter :: P0 = 1000 ! standard pressure [hPa]
  real, parameter :: kappa = 0.2854 !  For dry air

  theta = Tper + 300  ! Potential Temperature [K]
  T = theta*(P/P0)**kappa
end subroutine PERTHETA2T

!!$  do i=1, nvars_in
!!$     status = nf90_inquire_variable(ncid, myVarIDs(i), varname, ndims = NN)
!!$     if(status /= nf90_NoErr) print*, 'ERROR: NetCDF variable name cannot be assigned'
!!$     status = nf90_inq_varid(ncid, varname, VarId)
!!$
!!$     if(status /= nf90_NoErr) print*, 'ERROR: NetCDF variable ID for ',trim(varname),' cannot be retrieved'
!!$
!!$     ! Assigning the data to RT3/4 variable names
!!$     status = nf90_ebadtype
!!$     select case(trim(varname))
!!$        ! *** Reading for WRF SURFACE variables:
!!$     case('T2')
!!$        status = nf90_get_var(ncid, VarId, temp_tmp(:, :, 0, :))
!!$     case('PSFC')
!!$        status = nf90_get_var(ncid, VarId, press_tmp(:, :, 0, :))
!!$     case('Q2')
!!$        status = nf90_get_var(ncid, VarId, mixratio(:, :, 0, :))
!!$     case('XLAT')
!!$        status = nf90_get_var(ncid, VarId, lat, start=(/1,1,1/), count=(/ngridx, ngridy, 1/))
!!$     case('XLONG')
!!$        status = nf90_get_var(ncid, VarId, lon, start=(/1,1,1/), count=(/ngridx, ngridy, 1/))
!!$        ! *** Reading for WRF PROFILE variables:
!!$     case('PHB')
!!$        status = nf90_get_var(ncid, VarId, hgt_tmp)
!!$        hgt_tmp = hgt_tmp/9.81
!!$     case('P_HYD')
!!$        status = nf90_get_var(ncid, VarId, press_tmp(:, :, 1:nlyr, :))
!!$        press_tmp = press_tmp*1E-2  ! [hPa]
!!$     case('T')
!!$        status = nf90_get_var(ncid, VarId, temp_tmp(:, :, 1:nlyr, :))
!!$     case('QVAPOR')
!!$        status = nf90_get_var(ncid, VarId, mixratio(:, :, 1:nlyr, :))
!!$     case('QCLOUD')
!!$        status = nf90_get_var(ncid, VarId, cloud_water_tmp)
!!$     case('QRAIN')
!!$        status = nf90_get_var(ncid, VarId, rain_water_tmp)
!!$     case('QICE')
!!$        status = nf90_get_var(ncid, VarId, cloud_ice_tmp)
!!$     case('QSNOW')
!!$        status = nf90_get_var(ncid, VarId, snow_tmp)
!!$     case('QGRAUP')
!!$        status = nf90_get_var(ncid, VarId, graupel_tmp)
!!$     case('V')
!!$        status = nf90_get_var(ncid, VarId, V_Vel, start=(/1,2,1,1/) )
!!$     case('U')
!!$        status = nf90_get_var(ncid, VarId, U_Vel, start=(/2,1,1,1/) )
!!$     case('Times')
!!$        status = nf90_get_var(ncid, VarId, TimeStamp)
!!$     case('QXI')
!!$        status = nf90_get_var(ncid, VarId, qidx)
!!$     case default
!!$        print*, 'WARNING: WRF variable ', trim(varname),' not being used.'
!!$        continue
!!$     end select
!!$     if(status /= nf90_NoErr) print*, 'ERROR: assigning variable ', varname, nf90_strerror(status)
!!$
!!$  end do
